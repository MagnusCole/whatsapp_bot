ðŸ“‚ backend/

ðŸ“„ backend\main.py
---
from fastapi import FastAPI, WebSocket
from fastapi.middleware.cors import CORSMiddleware

app = FastAPI()

# Enable CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # In production, replace with your frontend URL
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/")
async def root():
    return {"message": "WhatsApp Bot API is running"}

@app.websocket("/ws/{client_id}")
async def websocket_endpoint(websocket: WebSocket, client_id: str):
    await websocket.accept()
    try:
        while True:
            data = await websocket.receive_text()
            await websocket.send_text(f"Message received: {data}")
    except:
        await websocket.close()
---

ðŸ“„ backend\requirements.txt
---
fastapi>=0.68.0,<0.69.0
uvicorn>=0.15.0,<0.16.0
pydantic>=1.8.0,<2.0.0
psycopg2-binary>=2.9.1,<3.0.0
websockets>=10.0,<11.0
python-dotenv>=0.19.0,<0.20.0
pytest>=6.2.4,<7.0.0
requests>=2.26.0,<3.0.0
drizzle-orm>=0.29.0
drizzle-migrations>=0.5.0
asyncpg>=0.28.0
pytest-asyncio>=0.21.0
pytest-cov>=4.1.0
httpx>=0.25.0
---

ðŸ“‚ backend\src/

ðŸ“‚ backend\src\api/

ðŸ“„ backend\src\api\messages.py
---
from fastapi import APIRouter, Depends, WebSocket, WebSocketDisconnect, HTTPException, status
from typing import List, Dict, Optional
from ..core.auth import verify_token, verify_api_key
from ..services.message import MessageService
from pydantic import BaseModel

router = APIRouter()

# WebSocket connections store
class ConnectionManager:
    def __init__(self):
        self.active_connections: Dict[str, WebSocket] = {}

    async def connect(self, websocket: WebSocket, client_id: str):
        await websocket.accept()
        self.active_connections[client_id] = websocket

    def disconnect(self, client_id: str):
        self.active_connections.pop(client_id, None)

    async def send_message(self, message: dict, client_id: str):
        if client_id in self.active_connections:
            await self.active_connections[client_id].send_json(message)

manager = ConnectionManager()

# Request/Response models
class MessageCreate(BaseModel):
    content: str
    receiver_id: str
    message_type: str = "text"
    metadata: Optional[Dict] = None

class MessageResponse(BaseModel):
    id: int
    content: str
    sender_id: str
    receiver_id: str
    message_type: str
    status: str
    metadata: Dict
    created_at: str

@router.websocket("/ws/{client_id}")
async def websocket_endpoint(websocket: WebSocket, client_id: str):
    await manager.connect(websocket, client_id)
    try:
        while True:
            data = await websocket.receive_json()
            # Process received message
            # You can add message handling logic here
            await manager.send_message({"status": "received", "data": data}, client_id)
    except WebSocketDisconnect:
        manager.disconnect(client_id)

@router.post("/messages", response_model=MessageResponse)
async def create_message(
    message: MessageCreate,
    service: MessageService = Depends(),
    token_data = Depends(verify_token)
):
    created_message = await service.create_message(
        content=message.content,
        sender_id=token_data.username,
        receiver_id=message.receiver_id,
        message_type=message.message_type,
        metadata=message.metadata
    )
    
    # Notify receiver through WebSocket if connected
    await manager.send_message(
        {"type": "new_message", "message": created_message.dict()},
        message.receiver_id
    )
    
    return created_message

@router.get("/messages/{message_id}", response_model=MessageResponse)
async def get_message(
    message_id: int,
    service: MessageService = Depends(),
    token_data = Depends(verify_token)
):
    message = await service.get_message(message_id)
    if not message:
        raise HTTPException(status_code=404, detail="Message not found")
    return message

@router.get("/conversations/{other_user_id}", response_model=List[MessageResponse])
async def get_conversation(
    other_user_id: str,
    service: MessageService = Depends(),
    token_data = Depends(verify_token)
):
    return await service.get_conversation(token_data.username, other_user_id)

@router.put("/messages/{message_id}/status")
async def update_message_status(
    message_id: int,
    status: str,
    service: MessageService = Depends(),
    api_key: str = Depends(verify_api_key)
):
    success = await service.update_message_status(message_id, status)
    if not success:
        raise HTTPException(status_code=404, detail="Message not found")
    return {"status": "updated"}
---

ðŸ“‚ backend\src\core/

ðŸ“„ backend\src\core\auth.py
---
from datetime import datetime, timedelta
from typing import Optional

from fastapi import Depends, HTTPException, status
from fastapi.security import APIKeyHeader, OAuth2PasswordBearer
from jose import JWTError, jwt
from passlib.context import CryptContext
from pydantic import BaseModel

# Security configurations
SECRET_KEY = "your-secret-key"  # Change this in production!
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

# Password hashing
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# Token handling
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
api_key_header = APIKeyHeader(name="X-API-Key", auto_error=False)

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: Optional[str] = None

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

async def verify_token(token: str = Depends(oauth2_scheme)) -> TokenData:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
        token_data = TokenData(username=username)
    except JWTError:
        raise credentials_exception
    return token_data

async def verify_api_key(api_key: str = Depends(api_key_header)) -> str:
    if api_key is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="API Key is missing"
        )
    # Replace hardcoded key with database lookup
    stored_api_key = await get_api_key_from_db(api_key)  # New function needed
    if not stored_api_key:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid API Key"
        )
    return api_key
---

ðŸ“„ backend\src\core\config.py
---
from pydantic import BaseSettings
from functools import lru_cache
import os
from typing import Optional

class Settings(BaseSettings):
    # API Settings
    API_V1_PREFIX: str = "/api/v1"
    PROJECT_NAME: str = "WhatsApp Bot Backend"
    DEBUG: bool = False

    # Database Settings
    DB_HOST: str = os.getenv("DB_HOST", "localhost")
    DB_PORT: int = int(os.getenv("DB_PORT", "5432"))
    DB_USER: str = os.getenv("DB_USER", "postgres")
    DB_PASSWORD: str = os.getenv("DB_PASSWORD", "")
    DB_NAME: str = os.getenv("DB_NAME", "whatsapp_bot")

    # Security Settings
    SECRET_KEY: str = os.getenv("SECRET_KEY", "your-secret-key-here")
    API_KEY_NAME: str = "X-API-Key"
    API_KEY: str = os.getenv("API_KEY", "your-api-key-here")
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30

    # Queue Settings (for future implementation)
    QUEUE_HOST: Optional[str] = None
    QUEUE_PORT: Optional[int] = None
    QUEUE_TYPE: str = "redis"  # or "rabbitmq"

    class Config:
        case_sensitive = True
        env_file = ".env"

@lru_cache()
def get_settings() -> Settings:
    return Settings()
---

ðŸ“„ backend\src\core\database.py
---
from drizzle_orm import PostgresDatabase
from drizzle_orm.asyncpg import AsyncPgConnection
from asyncpg import create_pool
from typing import Optional
from .config import get_settings

class Database:
    def __init__(self):
        self.pool: Optional[AsyncPgConnection] = None
        self.db: Optional[PostgresDatabase] = None

    async def connect(self):
        if not self.pool:
            settings = get_settings()
            self.pool = await create_pool(
                user=settings.DB_USER,
                password=settings.DB_PASSWORD,
                database=settings.DB_NAME,
                host=settings.DB_HOST,
                port=settings.DB_PORT
            )
            self.db = PostgresDatabase(self.pool)
        return self.db

    async def disconnect(self):
        if self.pool:
            await self.pool.close()
            self.pool = None
            self.db = None

# Create a database instance
database = Database()

# Dependency to get database connection
async def get_db():
    db = await database.connect()
    try:
        yield db
    finally:
        await database.disconnect()
---

ðŸ“„ backend\src\core\logging.py
---
import logging
import logging.config
import yaml
from pathlib import Path
from .config import get_settings

def setup_logging():
    settings = get_settings()
    
    # Default logging configuration
    logging_config = {
        'version': 1,
        'disable_existing_loggers': False,
        'formatters': {
            'standard': {
                'format': '%(asctime)s [%(levelname)s] %(name)s: %(message)s'
            },
            'json': {
                'format': '%(asctime)s %(levelname)s %(name)s %(message)s',
                'class': 'pythonjsonlogger.jsonlogger.JsonFormatter'
            }
        },
        'handlers': {
            'console': {
                'class': 'logging.StreamHandler',
                'formatter': 'standard',
                'level': 'INFO'
            },
            'file': {
                'class': 'logging.handlers.RotatingFileHandler',
                'filename': 'logs/app.log',
                'maxBytes': 10485760,  # 10MB
                'backupCount': 5,
                'formatter': 'json',
                'level': 'INFO'
            }
        },
        'loggers': {
            '': {  # Root logger
                'handlers': ['console', 'file'],
                'level': 'INFO',
                'propagate': True
            },
            'uvicorn': {
                'handlers': ['console', 'file'],
                'level': 'INFO',
                'propagate': False
            },
            'fastapi': {
                'handlers': ['console', 'file'],
                'level': 'INFO',
                'propagate': False
            }
        }
    }

    # Create logs directory if it doesn't exist
    Path('logs').mkdir(exist_ok=True)

    # Try to load custom logging config from file
    config_path = Path('config/logging.yaml')
    if config_path.exists():
        with open(config_path) as f:
            try:
                logging_config = yaml.safe_load(f)
            except Exception as e:
                print(f"Error loading logging config: {e}")

    # Apply configuration
    logging.config.dictConfig(logging_config)

    # Return root logger
    return logging.getLogger()
---

ðŸ“„ backend\src\core\logging_config.py
---
import logging.config
import yaml
from pathlib import Path
from typing import Dict, Any

def setup_logging(config_path: Path = None, default_level: int = logging.INFO) -> None:
    """Setup logging configuration

    Args:
        config_path (Path): Path to the logging configuration file
        default_level (int): Default logging level if config file is not found
    """
    if config_path and config_path.exists():
        with open(config_path, 'rt') as f:
            try:
                config = yaml.safe_load(f.read())
                logging.config.dictConfig(config)
            except Exception as e:
                print(f'Error loading logging configuration: {e}')
                setup_default_logging(default_level)
    else:
        setup_default_logging(default_level)

def setup_default_logging(level: int = logging.INFO) -> None:
    """Setup default logging configuration

    Args:
        level (int): Logging level
    """
    config = {
        'version': 1,
        'disable_existing_loggers': False,
        'formatters': {
            'json': {
                'format': '%(asctime)s %(levelname)s %(name)s %(message)s',
                'class': 'pythonjsonlogger.jsonlogger.JsonFormatter',
                'json_ensure_ascii': False
            },
            'standard': {
                'format': '%(asctime)s [%(levelname)s] %(name)s: %(message)s'
            },
            'detailed': {
                'format': '%(asctime)s [%(levelname)s] %(name)s:%(lineno)d: %(message)s'
            }
        },
        'handlers': {
            'console': {
                'class': 'logging.StreamHandler',
                'level': 'INFO',
                'formatter': 'standard',
                'stream': 'ext://sys.stdout'
            },
            'file': {
                'class': 'logging.handlers.RotatingFileHandler',
                'level': 'DEBUG',
                'formatter': 'detailed',
                'filename': 'logs/app.log',
                'maxBytes': 10485760,  # 10MB
                'backupCount': 5
            },
            'error_file': {
                'class': 'logging.handlers.RotatingFileHandler',
                'level': 'ERROR',
                'formatter': 'detailed',
                'filename': 'logs/error.log',
                'maxBytes': 10485760,  # 10MB
                'backupCount': 5
            }
        },
        'loggers': {
            '': {  # root logger
                'handlers': ['console', 'file', 'error_file'],
                'level': level,
                'propagate': True
            }
        }
    }
    logging.config.dictConfig(config)

def get_logger(name: str) -> logging.Logger:
    """Get a logger instance with the specified name

    Args:
        name (str): Logger name

    Returns:
        logging.Logger: Logger instance
    """
    return logging.getLogger(name)
---

ðŸ“„ backend\src\core\middleware.py
---
from fastapi import Request, HTTPException
from fastapi.responses import JSONResponse
from starlette.middleware.base import BaseHTTPMiddleware
from typing import Union, Dict, Any
from .logging_config import get_logger

logger = get_logger(__name__)

class ErrorHandlerMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        try:
            response = await call_next(request)
            return response
        except HTTPException as exc:
            logger.warning(f"HTTP Exception: {exc.detail}")
            return JSONResponse(
                status_code=exc.status_code,
                content={"error": exc.detail}
            )
        except Exception as exc:
            logger.error(f"Unhandled exception: {str(exc)}", exc_info=True)
            return JSONResponse(
                status_code=500,
                content={"error": "Internal server error"}
            )

class RequestLoggingMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        request_id = str(uuid.uuid4())
        logger.info(f"Request: {request.method} {request.url}", 
                   extra={"request_id": request_id})
        response = await call_next(request)
        logger.info(f"Response: {response.status_code}",
                   extra={"request_id": request_id})
        return response

class APIKeyValidationError(HTTPException):
    def __init__(self, detail: str = "Invalid API Key"):
        super().__init__(status_code=403, detail=detail)

class ValidationError(HTTPException):
    def __init__(self, detail: Union[str, Dict[str, Any]]):
        super().__init__(status_code=422, detail=detail)

class NotFoundError(HTTPException):
    def __init__(self, detail: str = "Resource not found"):
        super().__init__(status_code=404, detail=detail)
---

ðŸ“„ backend\src\core\queue.py
---
from abc import ABC, abstractmethod
from typing import Any, Optional, Dict
from .config import Settings

class QueueBase(ABC):
    """Abstract base class for queue implementations"""
    
    @abstractmethod
    async def connect(self) -> None:
        """Establish connection to the queue service"""
        pass

    @abstractmethod
    async def disconnect(self) -> None:
        """Close connection to the queue service"""
        pass

    @abstractmethod
    async def publish(self, queue: str, message: Any) -> None:
        """Publish a message to the specified queue"""
        pass

    @abstractmethod
    async def subscribe(self, queue: str, callback: callable) -> None:
        """Subscribe to a queue and process messages with callback"""
        pass

class RedisQueue(QueueBase):
    """Redis queue implementation (skeleton)"""
    
    def __init__(self, settings: Settings):
        self.settings = settings
        self.connection = None

    async def connect(self) -> None:
        # TODO: Implement Redis connection
        pass

    async def disconnect(self) -> None:
        # TODO: Implement Redis disconnection
        pass

    async def publish(self, queue: str, message: Any) -> None:
        # TODO: Implement Redis publish
        pass

    async def subscribe(self, queue: str, callback: callable) -> None:
        # TODO: Implement Redis subscribe
        pass

class RabbitMQQueue(QueueBase):
    """RabbitMQ queue implementation (skeleton)"""
    
    def __init__(self, settings: Settings):
        self.settings = settings
        self.connection = None
        self.channel = None

    async def connect(self) -> None:
        # TODO: Implement RabbitMQ connection
        pass

    async def disconnect(self) -> None:
        # TODO: Implement RabbitMQ disconnection
        pass

    async def publish(self, queue: str, message: Any) -> None:
        # TODO: Implement RabbitMQ publish
        pass

    async def subscribe(self, queue: str, callback: callable) -> None:
        # TODO: Implement RabbitMQ subscribe
        pass

def get_queue_client(settings: Settings) -> QueueBase:
    """Factory function to get appropriate queue client based on settings"""
    if settings.QUEUE_TYPE.lower() == 'redis':
        return RedisQueue(settings)
    elif settings.QUEUE_TYPE.lower() == 'rabbitmq':
        return RabbitMQQueue(settings)
    else:
        raise ValueError(f"Unsupported queue type: {settings.QUEUE_TYPE}")
---

ðŸ“„ backend\src\main.py
---
from fastapi import FastAPI, WebSocket, HTTPException, Depends
from fastapi.middleware.cors import CORSMiddleware
from typing import Dict
import json
from pathlib import Path

from .core.auth import get_api_key
from .core.config import Settings, get_settings
from .core.logging_config import setup_logging
from .core.middleware import ErrorHandlerMiddleware, RequestLoggingMiddleware
from .core.queue import get_queue_client
from .services.event_manager import event_manager

# Setup logging
setup_logging(Path('config/logging.yaml'))
from .core.logging_config import get_logger
logger = get_logger(__name__)

app = FastAPI(title="Messaging Bot Backend")

# Configure CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # In production, replace with specific origins
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Add custom middleware
app.add_middleware(ErrorHandlerMiddleware)
app.add_middleware(RequestLoggingMiddleware)

@app.get("/", dependencies=[Depends(get_api_key)])
async def read_root():
    return {"status": "ok", "service": "messaging-bot-backend"}

@app.websocket("/ws/{client_id}")
async def websocket_endpoint(websocket: WebSocket, client_id: str):
    await event_manager.register_websocket(client_id, websocket)
    
    try:
        while True:
            data = await websocket.receive_text()
            message = json.loads(data)
            await event_manager.handle_client_message(client_id, message)
    except Exception as e:
        logger.error(f"WebSocket error for client {client_id}: {str(e)}")

@app.post("/webhook/register/{client_id}", dependencies=[Depends(get_api_key)])
async def register_webhook(client_id: str, webhook_url: str):
    try:
        event_manager.register_webhook(client_id, webhook_url)
        return {"status": "success", "message": f"Webhook registered for client {client_id}"}
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

# Initialize queue client
queue_client = None

# Start background tasks when the application starts
@app.on_event("startup")
async def startup_event():
    global queue_client
    settings = get_settings()
    queue_client = get_queue_client(settings)
    await queue_client.connect()
    event_manager.start_background_tasks()

# Cleanup when the application shuts down
@app.on_event("shutdown")
async def shutdown_event():
    if queue_client:
        await queue_client.disconnect()

if __name__ == "__main__":
    import uvicorn
    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=True)
---

ðŸ“‚ backend\src\models/

ðŸ“„ backend\src\models\message.py
---
from datetime import datetime
from typing import Optional
from drizzle_orm import *
from drizzle_orm.postgresql import *

class Messages(PostgresTable):
    id = serial('id').primary_key()
    content = text('content').not_null()
    sender_id = text('sender_id').not_null()
    receiver_id = text('receiver_id').not_null()
    message_type = text('message_type').not_null()  # text, image, video, etc
    status = text('status').not_null()  # sent, delivered, read
    metadata = json('metadata').default('{}')
    created_at = timestamp('created_at').default(datetime.utcnow)
    updated_at = timestamp('updated_at').default(datetime.utcnow)

class MessageAttachments(PostgresTable):
    id = serial('id').primary_key()
    message_id = integer('message_id').references(Messages.id)
    file_type = text('file_type').not_null()  # image, video, document
    file_url = text('file_url').not_null()
    file_name = text('file_name')
    file_size = integer('file_size')
    created_at = timestamp('created_at').default(datetime.utcnow)
---

ðŸ“‚ backend\src\models\migrations/

ðŸ“‚ backend\src\services/

ðŸ“„ backend\src\services\event_manager.py
---
from typing import Dict, Optional, List, Callable, Any
from fastapi import WebSocket, BackgroundTasks
import asyncio
import json
import logging
import aiohttp
from datetime import datetime
from ..models.message import Messages

logger = logging.getLogger(__name__)

class EventManager:
    def __init__(self):
        self.active_connections: Dict[str, WebSocket] = {}
        self.webhook_urls: Dict[str, str] = {}
        self.message_queue: asyncio.Queue = asyncio.Queue()
        self.background_tasks: BackgroundTasks = BackgroundTasks()

    async def register_websocket(self, client_id: str, websocket: WebSocket):
        await websocket.accept()
        self.active_connections[client_id] = websocket
        logger.info(f"Client {client_id} connected via WebSocket")

    def register_webhook(self, client_id: str, webhook_url: str):
        self.webhook_urls[client_id] = webhook_url
        logger.info(f"Client {client_id} registered webhook at {webhook_url}")

    async def broadcast_message(self, message: Dict[str, Any]):
        # Add message to queue for processing
        await self.message_queue.put(message)
        
        # Process WebSocket delivery
        websocket_tasks = []
        for client_id, ws in self.active_connections.items():
            task = asyncio.create_task(self._send_ws_message(client_id, ws, message))
            websocket_tasks.append(task)
        
        # Process webhook delivery for clients without active WebSocket
        webhook_tasks = []
        for client_id, url in self.webhook_urls.items():
            if client_id not in self.active_connections:
                task = asyncio.create_task(self._send_webhook(client_id, url, message))
                webhook_tasks.append(task)
        
        # Wait for all deliveries to complete
        await asyncio.gather(*websocket_tasks, *webhook_tasks)

    async def _send_ws_message(self, client_id: str, websocket: WebSocket, message: Dict[str, Any]):
        try:
            await websocket.send_text(json.dumps(message))
            logger.info(f"Message sent to client {client_id} via WebSocket")
        except Exception as e:
            logger.error(f"WebSocket delivery failed for client {client_id}: {str(e)}")
            # Remove failed connection and try webhook fallback
            if client_id in self.active_connections:
                del self.active_connections[client_id]
            if client_id in self.webhook_urls:
                await self._send_webhook(client_id, self.webhook_urls[client_id], message)

    async def _send_webhook(self, client_id: str, webhook_url: str, message: Dict[str, Any]):
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(webhook_url, json=message) as response:
                    if response.status == 200:
                        logger.info(f"Message sent to client {client_id} via webhook")
                    else:
                        logger.error(f"Webhook delivery failed for client {client_id}: HTTP {response.status}")
        except Exception as e:
            logger.error(f"Webhook delivery failed for client {client_id}: {str(e)}")

    async def process_message_queue(self):
        while True:
            try:
                message = await self.message_queue.get()
                await self.broadcast_message(message)
                self.message_queue.task_done()
            except Exception as e:
                logger.error(f"Error processing message queue: {str(e)}")
            await asyncio.sleep(0.1)  # Prevent CPU overload

    def start_background_tasks(self):
        asyncio.create_task(self.process_message_queue())

    async def handle_client_message(self, client_id: str, message: Dict[str, Any]):
        try:
            # Enhance message with metadata
            enhanced_message = {
                "type": "message",
                "client_id": client_id,
                "content": message,
                "timestamp": datetime.utcnow().isoformat()
            }
            
            # Broadcast to all clients
            await self.broadcast_message(enhanced_message)
            
            return True
        except Exception as e:
            logger.error(f"Error handling message from client {client_id}: {str(e)}")
            return False

# Create a singleton instance
event_manager = EventManager()
---

ðŸ“„ backend\src\services\message.py
---
from typing import List, Optional, Dict
from datetime import datetime
from drizzle_orm import *
from ..models.message import Messages, MessageAttachments

class MessageService:
    def __init__(self, db):
        self.db = db

    async def create_message(self, 
        content: str,
        sender_id: str,
        receiver_id: str,
        message_type: str = "text",
        metadata: Dict = None
    ) -> Messages:
        message = Messages(
            content=content,
            sender_id=sender_id,
            receiver_id=receiver_id,
            message_type=message_type,
            status="sent",
            metadata=metadata or {}
        )
        return await self.db.insert(message)

    async def get_message(self, message_id: int) -> Optional[Messages]:
        return await self.db.select(Messages).where(Messages.id == message_id).first()

    async def get_conversation(self, user1_id: str, user2_id: str, limit: int = 50) -> List[Messages]:
        return await self.db.select(Messages).where(
            or_(
                and_(Messages.sender_id == user1_id, Messages.receiver_id == user2_id),
                and_(Messages.sender_id == user2_id, Messages.receiver_id == user1_id)
            )
        ).order_by(desc(Messages.created_at)).limit(limit).all()

    async def update_message_status(self, message_id: int, status: str) -> bool:
        message = await self.get_message(message_id)
        if not message:
            return False
        
        await self.db.update(Messages).where(Messages.id == message_id).set({
            "status": status,
            "updated_at": datetime.utcnow()
        })
        return True

    async def add_attachment(self,
        message_id: int,
        file_type: str,
        file_url: str,
        file_name: Optional[str] = None,
        file_size: Optional[int] = None
    ) -> MessageAttachments:
        attachment = MessageAttachments(
            message_id=message_id,
            file_type=file_type,
            file_url=file_url,
            file_name=file_name,
            file_size=file_size
        )
        return await self.db.insert(attachment)

    async def get_message_attachments(self, message_id: int) -> List[MessageAttachments]:
        return await self.db.select(MessageAttachments).where(
            MessageAttachments.message_id == message_id
        ).all()
---

ðŸ“‚ backend\tests/

ðŸ“„ backend\tests\conftest.py
---
import pytest
from asyncio import get_event_loop
from typing import AsyncGenerator, Generator
from fastapi.testclient import TestClient
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from drizzle_orm import PostgresDatabase
from drizzle_orm.asyncpg import AsyncPgConnection
from asyncpg import create_pool
from src.core.config import get_settings
from src.core.database import Database
from src.main import app

@pytest.fixture(scope="session")
def event_loop() -> Generator:
    loop = get_event_loop()
    yield loop
    loop.close()

@pytest.fixture(scope="session")
async def test_db() -> AsyncGenerator[PostgresDatabase, None]:
    settings = get_settings()
    # Use test database
    test_db_url = f"postgresql://{settings.DB_USER}:{settings.DB_PASSWORD}@{settings.DB_HOST}:{settings.DB_PORT}/test_{settings.DB_NAME}"
    
    # Create test database connection
    pool = await create_pool(
        test_db_url,
        min_size=2,
        max_size=10
    )
    
    db = PostgresDatabase(pool)
    yield db
    await pool.close()

@pytest.fixture(scope="function")
def test_client() -> Generator[TestClient, None, None]:
    with TestClient(app) as client:
        yield client

@pytest.fixture(scope="function")
async def clean_db(test_db: PostgresDatabase) -> None:
    # Clean up tables after each test
    await test_db.execute("TRUNCATE users, messages, sessions, conversations CASCADE;")

@pytest.fixture
def mock_websocket_client():
    class MockWebSocket:
        async def send_text(self, data: str):
            pass
        
        async def receive_text(self) -> str:
            return "{\"type\": \"message\", \"content\": \"test\"}"
        
        async def close(self):
            pass
    
    return MockWebSocket()
---

ðŸ“„ backend\tests\locustfile.py
---
from locust import HttpUser, task, between
from typing import Dict
import json
import random

class WhatsAppUser(HttpUser):
    wait_time = between(1, 3)  # Wait 1-3 seconds between tasks
    
    def on_start(self):
        # Simulate user registration/login
        self.user_id = str(random.randint(1, 1000))
        self.api_key = f"test_api_key_{self.user_id}"
        self.headers = {"Authorization": f"Bearer {self.api_key}"}
    
    @task(3)
    def send_message(self):
        # Simulate sending messages
        message_data = {
            "content": f"Load test message {random.randint(1, 1000)}",
            "receiver_id": str(random.randint(1, 1000)),
            "message_type": "text"
        }
        self.client.post(
            "/api/messages/send",
            json=message_data,
            headers=self.headers
        )
    
    @task(2)
    def get_conversation(self):
        # Simulate retrieving conversation history
        other_user = str(random.randint(1, 1000))
        self.client.get(
            f"/api/messages/conversation/{other_user}",
            headers=self.headers
        )
    
    @task(1)
    def update_status(self):
        # Simulate updating message status
        message_id = random.randint(1, 1000)
        status_data = {"status": "read"}
        self.client.put(
            f"/api/messages/{message_id}/status",
            json=status_data,
            headers=self.headers
        )

# To run:
# locust -f locustfile.py --host=http://localhost:8000
# Then open http://localhost:8089 in browser
#
# Configuration recommendations:
# - Start with 10 users, spawn rate 1 user/second
# - Gradually increase to 100 users to test system limits
# - Monitor response times and error rates
# - Watch for database connection pool exhaustion
# - Monitor WebSocket connection limits
---

ðŸ“‚ backend\tests\test_api/

ðŸ“„ backend\tests\test_api\test_endpoints.py
---
import pytest
from fastapi.testclient import TestClient
from src.main import app
from src.core.security import create_api_key

@pytest.fixture
def test_api_key():
    return create_api_key()

def test_health_check(test_client: TestClient):
    response = test_client.get("/health")
    assert response.status_code == 200
    assert response.json() == {"status": "healthy"}

def test_auth_required(test_client: TestClient):
    response = test_client.post("/api/messages/send")
    assert response.status_code == 401

def test_send_message(test_client: TestClient, test_api_key: str):
    headers = {"X-API-Key": test_api_key}
    message_data = {
        "content": "Test message",
        "receiver_id": "123",
        "message_type": "text"
    }
    
    response = test_client.post(
        "/api/messages/send",
        json=message_data,
        headers=headers
    )
    assert response.status_code == 200
    assert "message_id" in response.json()

def test_get_messages(test_client: TestClient, test_api_key: str):
    headers = {"X-API-Key": test_api_key}
    response = test_client.get(
        "/api/messages/list",
        headers=headers
    )
    assert response.status_code == 200
    assert isinstance(response.json(), list)

def test_webhook_handler(test_client: TestClient, test_api_key: str):
    headers = {"X-API-Key": test_api_key}
    webhook_data = {
        "event": "message",
        "data": {
            "message_id": "123",
            "status": "delivered"
        }
    }
    
    response = test_client.post(
        "/api/webhooks/message-status",
        json=webhook_data,
        headers=headers
    )
    assert response.status_code == 200

@pytest.mark.asyncio
async def test_message_flow(test_client: TestClient, test_api_key: str, test_db):
    # Test complete message flow: send -> deliver -> read
    headers = {"X-API-Key": test_api_key}
    
    # Send message
    send_response = test_client.post(
        "/api/messages/send",
        json={
            "content": "Flow test message",
            "receiver_id": "456",
            "message_type": "text"
        },
        headers=headers
    )
    assert send_response.status_code == 200
    message_id = send_response.json()["message_id"]
    
    # Update to delivered
    deliver_response = test_client.post(
        "/api/webhooks/message-status",
        json={
            "event": "message",
            "data": {
                "message_id": message_id,
                "status": "delivered"
            }
        },
        headers=headers
    )
    assert deliver_response.status_code == 200
    
    # Verify message status
    status_response = test_client.get(
        f"/api/messages/{message_id}",
        headers=headers
    )
    assert status_response.status_code == 200
    assert status_response.json()["status"] == "delivered"
---

ðŸ“„ backend\tests\test_message_service.py
---
import pytest
from datetime import datetime
from typing import List
from src.services.message import MessageService
from src.models.message import Messages, MessageAttachments

@pytest.mark.asyncio
async def test_create_message(test_db, clean_db):
    message_service = MessageService(test_db)
    message = await message_service.create_message(
        content="Test message",
        sender_id="1",
        receiver_id="2",
        message_type="text"
    )
    
    assert message.content == "Test message"
    assert message.sender_id == "1"
    assert message.receiver_id == "2"
    assert message.status == "sent"

@pytest.mark.asyncio
async def test_get_message(test_db, clean_db):
    message_service = MessageService(test_db)
    created_message = await message_service.create_message(
        content="Test message",
        sender_id="1",
        receiver_id="2"
    )
    
    retrieved_message = await message_service.get_message(created_message.id)
    assert retrieved_message is not None
    assert retrieved_message.id == created_message.id
    assert retrieved_message.content == created_message.content

@pytest.mark.asyncio
async def test_update_message_status(test_db, clean_db):
    message_service = MessageService(test_db)
    message = await message_service.create_message(
        content="Test message",
        sender_id="1",
        receiver_id="2"
    )
    
    success = await message_service.update_message_status(message.id, "delivered")
    assert success is True
    
    updated_message = await message_service.get_message(message.id)
    assert updated_message.status == "delivered"

@pytest.mark.asyncio
async def test_get_conversation(test_db, clean_db):
    message_service = MessageService(test_db)
    # Create multiple messages between two users
    for i in range(5):
        await message_service.create_message(
            content=f"Message {i}",
            sender_id="1",
            receiver_id="2"
        )
        await message_service.create_message(
            content=f"Reply {i}",
            sender_id="2",
            receiver_id="1"
        )
    
    conversation = await message_service.get_conversation("1", "2", limit=10)
    assert len(conversation) == 10

@pytest.mark.asyncio
async def test_high_concurrency_message_creation(test_db, clean_db):
    message_service = MessageService(test_db)
    message_count = 100
    
    # Create multiple messages concurrently
    async def create_messages() -> List[Messages]:
        tasks = []
        for i in range(message_count):
            task = message_service.create_message(
                content=f"Concurrent message {i}",
                sender_id=str(i % 10),  # Simulate 10 different senders
                receiver_id=str((i + 1) % 10),
                message_type="text",
                metadata={"concurrent_test": True}
            )
            tasks.append(task)
        return await asyncio.gather(*tasks)
    
    messages = await create_messages()
    assert len(messages) == message_count
    
    # Verify all messages were created successfully
    for msg in messages:
        assert msg.id is not None
        assert msg.status == "sent"
        assert msg.metadata.get("concurrent_test") is True

@pytest.mark.asyncio
async def test_message_attachments(test_db, clean_db):
    message_service = MessageService(test_db)
    message = await message_service.create_message(
        content="Message with attachment",
        sender_id="1",
        receiver_id="2"
    )
    
    # Add attachment to message
    attachment = await message_service.add_attachment(
        message_id=message.id,
        file_type="image",
        file_url="https://example.com/image.jpg",
        file_name="test_image.jpg",
        file_size=1024
    )
    
    assert attachment.message_id == message.id
    assert attachment.file_type == "image"
    
    # Get message attachments
    attachments = await message_service.get_message_attachments(message.id)
    assert len(attachments) == 1
    assert attachments[0].file_url == "https://example.com/image.jpg"
---

ðŸ“„ backend\tests\test_websocket.py
---
import pytest
from fastapi import WebSocket
from src.services.event_manager import EventManager
from src.models.message import Messages
from datetime import datetime
import json

@pytest.mark.asyncio
async def test_websocket_connection(test_client, mock_websocket_client):
    event_manager = EventManager()
    await event_manager.connect(mock_websocket_client, "test_user")
    assert "test_user" in event_manager.active_connections
    await event_manager.disconnect("test_user")
    assert "test_user" not in event_manager.active_connections

@pytest.mark.asyncio
async def test_message_broadcast(test_client, mock_websocket_client, test_db):
    event_manager = EventManager()
    await event_manager.connect(mock_websocket_client, "user1")
    
    # Simulate message broadcast
    test_message = {
        "type": "message",
        "content": "Test broadcast message",
        "sender_id": "user1",
        "receiver_id": "user2"
    }
    await event_manager.broadcast_message("user2", json.dumps(test_message))
    
    # Verify message was sent through WebSocket
    assert len(event_manager.message_history) > 0
    assert event_manager.message_history[-1]["content"] == "Test broadcast message"

@pytest.mark.asyncio
async def test_concurrent_connections(test_client, test_db):
    event_manager = EventManager()
    connection_count = 50
    
    # Simulate multiple concurrent connections
    async def create_connections():
        tasks = []
        for i in range(connection_count):
            mock_ws = MockWebSocket()
            task = event_manager.connect(mock_ws, f"user_{i}")
            tasks.append(task)
        await asyncio.gather(*tasks)
    
    await create_connections()
    assert len(event_manager.active_connections) == connection_count
    
    # Clean up connections
    for i in range(connection_count):
        await event_manager.disconnect(f"user_{i}")
    
    assert len(event_manager.active_connections) == 0

@pytest.mark.asyncio
async def test_message_persistence(test_client, test_db, mock_websocket_client):
    event_manager = EventManager()
    message_service = MessageService(test_db)
    
    # Connect user and send message
    await event_manager.connect(mock_websocket_client, "test_sender")
    
    test_message = {
        "content": "Test persistent message",
        "sender_id": "test_sender",
        "receiver_id": "test_receiver",
        "type": "text"
    }
    
    # Send message and verify persistence
    message = await message_service.create_message(**test_message)
    assert message.id is not None
    
    # Verify message can be retrieved
    stored_message = await message_service.get_message(message.id)
    assert stored_message is not None
    assert stored_message.content == test_message["content"]
    
    await event_manager.disconnect("test_sender")

class MockWebSocket:
    async def send_text(self, data: str):
        self.last_sent = data
    
    async def receive_text(self) -> str:
        return json.dumps({
            "type": "message",
            "content": "test message",
            "sender_id": "test_user",
            "receiver_id": "test_receiver"
        })
    
    async def close(self):
        pass
---

ðŸ“‚ config/

ðŸ“„ config\logging.yaml
---
# Logging Configuration

version: 1
disable_existing_loggers: false

formatters:
  standard:
    format: "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
  json:
    class: pythonjsonlogger.jsonlogger.JsonFormatter
    format: "%(asctime)s %(name)s %(levelname)s %(message)s"

handlers:
  console:
    class: logging.StreamHandler
    level: DEBUG
    formatter: standard
    stream: ext://sys.stdout

  error_file:
    class: logging.handlers.RotatingFileHandler
    level: ERROR
    formatter: json
    filename: logs/error.log
    maxBytes: 10485760  # 10MB
    backupCount: 5
    encoding: utf8

  access_file:
    class: logging.handlers.RotatingFileHandler
    level: INFO
    formatter: json
    filename: logs/access.log
    maxBytes: 10485760  # 10MB
    backupCount: 5
    encoding: utf8

loggers:
  backend:
    level: INFO
    handlers: [console, error_file]
    propagate: false

  middleware:
    level: INFO
    handlers: [console, error_file]
    propagate: false

  access:
    level: INFO
    handlers: [access_file]
    propagate: false

root:
  level: INFO
  handlers: [console, error_file]
---

ðŸ“‚ database/

ðŸ“„ database\connection.py
---
from drizzle_orm import PostgresDatabase
from drizzle_orm.pg_core import create_engine
from contextlib import contextmanager
from typing import Generator

class DatabaseManager:
    def __init__(self, connection_string: str):
        self.engine = create_engine(connection_string)
        self.db = PostgresDatabase(self.engine)

    @contextmanager
    def get_session(self) -> Generator[PostgresDatabase, None, None]:
        try:
            yield self.db
        except Exception as e:
            raise e
---

ðŸ“‚ database\migrations/

ðŸ“„ database\migrations\001_initial.py
---
from drizzle_orm import PostgresDatabase
from drizzle_orm.pg_core import *
from datetime import datetime

def upgrade(db: PostgresDatabase):
    # Create Users table
    db.execute("""
    CREATE TABLE users (
        id SERIAL PRIMARY KEY,
        name TEXT NOT NULL,
        phone TEXT NOT NULL UNIQUE,
        api_key TEXT NOT NULL UNIQUE,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
    """)

    # Create Messages table with optimizations for high volume
    db.execute("""
    CREATE TABLE messages (
        id BIGSERIAL PRIMARY KEY,
        user_id INTEGER REFERENCES users(id),
        content TEXT NOT NULL,
        status TEXT NOT NULL DEFAULT 'pending',
        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        metadata JSONB DEFAULT '{}'
    );
    CREATE INDEX messages_user_timestamp_idx ON messages(user_id, timestamp);
    CREATE INDEX messages_status_idx ON messages(status);
    """)

    # Create Sessions table
    db.execute("""
    CREATE TABLE sessions (
        id SERIAL PRIMARY KEY,
        user_id INTEGER REFERENCES users(id),
        connection_status TEXT NOT NULL DEFAULT 'offline',
        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        last_activity TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        device_info JSONB DEFAULT '{}'
    );
    CREATE INDEX sessions_user_status_idx ON sessions(user_id, connection_status);
    """)

    # Create Conversations table
    db.execute("""
    CREATE TABLE conversations (
        id SERIAL PRIMARY KEY,
        user_id INTEGER REFERENCES users(id),
        status TEXT NOT NULL DEFAULT 'active',
        last_activity TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        participant_ids INTEGER[],
        metadata JSONB DEFAULT '{}'
    );
    CREATE INDEX conversations_user_activity_idx ON conversations(user_id, last_activity);
    CREATE INDEX conversations_status_idx ON conversations(status);
    """)

def downgrade(db: PostgresDatabase):
    # Drop tables in reverse order to handle dependencies
    db.execute("DROP TABLE IF EXISTS conversations CASCADE;")
    db.execute("DROP TABLE IF EXISTS sessions CASCADE;")
    db.execute("DROP TABLE IF EXISTS messages CASCADE;")
    db.execute("DROP TABLE IF EXISTS users CASCADE;")
---

ðŸ“‚ database\repositories/

ðŸ“„ database\repositories\base.py
---
from typing import Generic, TypeVar, Type
from drizzle_orm import PostgresDatabase
from ..schema import Table

T = TypeVar('T', bound=Table)

class BaseRepository(Generic[T]):
    def __init__(self, db: PostgresDatabase, model: Type[T]):
        self.db = db
        self.model = model

    async def create(self, **kwargs) -> T:
        return await self.db.insert(self.model).values(**kwargs).returning()

    async def get_by_id(self, id: int) -> T:
        return await self.db.select(self.model).where(self.model.id == id).first()
---

ðŸ“„ database\schema.py
---
from datetime import datetime
from typing import Optional
from drizzle_orm import *
from drizzle_orm.pg_core import *

# Users table
class Users(Table):
    id = serial('id').primary_key()
    name = text('name').not_null()
    phone = text('phone').not_null().unique()
    api_key = text('api_key').not_null().unique()
    created_at = timestamp('created_at').default(datetime.utcnow)
    updated_at = timestamp('updated_at').default(datetime.utcnow)

# Messages table - Optimized for high volume
class Messages(Table):
    id = bigserial('id').primary_key()  # Using bigserial for high volume
    user_id = integer('user_id').references(Users.id)
    content = text('content').not_null()
    status = text('status').not_null().default('pending')  # pending, sent, delivered, read
    timestamp = timestamp('timestamp').default(datetime.utcnow).index()  # Indexed for faster queries
    metadata = jsonb('metadata').default({})  # For extensibility

    class Meta:
        indexes = [
            Index('messages_user_timestamp_idx', 'user_id', 'timestamp'),  # Optimize message history queries
            Index('messages_status_idx', 'status')  # Optimize status-based queries
        ]

# Sessions table
class Sessions(Table):
    id = serial('id').primary_key()
    user_id = integer('user_id').references(Users.id)
    connection_status = text('connection_status').not_null().default('offline')  # offline, online, away
    timestamp = timestamp('timestamp').default(datetime.utcnow)
    last_activity = timestamp('last_activity').default(datetime.utcnow)
    device_info = jsonb('device_info').default({})  # Store device-specific information

    class Meta:
        indexes = [
            Index('sessions_user_status_idx', 'user_id', 'connection_status')  # Optimize online status queries
        ]

# Conversations table
class Conversations(Table):
    id = serial('id').primary_key()
    user_id = integer('user_id').references(Users.id)
    status = text('status').not_null().default('active')  # active, archived, deleted
    last_activity = timestamp('last_activity').default(datetime.utcnow)
    participant_ids = array('participant_ids', integer)  # Array of user IDs in the conversation
    metadata = jsonb('metadata').default({})  # Store conversation settings, pins, etc.

    class Meta:
        indexes = [
            Index('conversations_user_activity_idx', 'user_id', 'last_activity'),  # Optimize recent conversations queries
            Index('conversations_status_idx', 'status')  # Optimize status-based filtering
        ]
---

ðŸ“‚ frontend/

ðŸ“‚ frontend\src/

ðŸ“‚ frontend\src\components/

ðŸ“„ frontend\src\components\MessageStream.tsx
---
import React, { useEffect, useState, useCallback } from 'react';
import { YourType } from '../types';

interface MessageStreamProps {
    clientId: string;
    onMessage?: (message: Message) => void;
    fallbackUrl?: string;
}

export const MessageStream: React.FC<MessageStreamProps> = ({ clientId, onMessage, fallbackUrl }) => {
    const [messages, setMessages] = useState<Message[]>([]);
    const [wsStatus, setWsStatus] = useState<'connecting' | 'connected' | 'disconnected'>('disconnected');
    const [ws, setWs] = useState<WebSocket | null>(null);

    const connectWebSocket = useCallback(() => {
        const wsUrl = `ws://localhost:8000/ws/${clientId}`;
        const socket = new WebSocket(wsUrl);

        socket.onopen = () => {
            setWsStatus('connected');
            console.log('WebSocket connected');
        };

        socket.onmessage = (event) => {
            const message = JSON.parse(event.data);
            setMessages(prev => [...prev, message]);
            onMessage?.(message);
        };

        socket.onclose = () => {
            setWsStatus('disconnected');
            console.log('WebSocket disconnected, attempting to reconnect...');
            // Attempt to reconnect after 5 seconds
            setTimeout(connectWebSocket, 5000);

            // If fallback URL is provided, register for webhook updates
            if (fallbackUrl) {
                registerWebhook();
            }
        };

        socket.onerror = (error) => {
            console.error('WebSocket error:', error);
            socket.close();
        };

        setWs(socket);
    }, [clientId, onMessage, fallbackUrl]);

    const registerWebhook = async () => {
        if (!fallbackUrl) return;

        try {
            const response = await fetch(`http://localhost:8000/webhook/register/${clientId}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ webhook_url: fallbackUrl }),
            });

            if (!response.ok) {
                throw new Error('Failed to register webhook');
            }

            console.log('Webhook registered successfully');
        } catch (error) {
            console.error('Error registering webhook:', error);
        }
    };

    const sendMessage = useCallback((content: string) => {
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ content }));
        } else {
            console.error('WebSocket is not connected');
        }
    }, [ws]);

    useEffect(() => {
        connectWebSocket();

        return () => {
            if (ws) {
                ws.close();
            }
        };
    }, [connectWebSocket]);

    return (
        <div className="message-stream">
            <div className="status-bar">
                Connection Status: {wsStatus}
            </div>
            <div className="messages">
                {messages.map((msg, index) => (
                    <div key={index} className="message">
                        <span className="timestamp">{new Date(msg.timestamp).toLocaleTimeString()}</span>
                        <span className="content">{msg.content}</span>
                    </div>
                ))}
            </div>
        </div>
    );
};
---

ðŸ“‚ frontend\src\types/

ðŸ“„ frontend\src\types\index.ts
---
// Basic types for the WhatsApp bot frontend

export interface Message {
  id: string;
  content: string;
  sender_id: string;
  receiver_id: string;
  timestamp: string;
  status: 'pending' | 'sent' | 'delivered' | 'read';
  metadata?: Record<string, any>;
}

export interface User {
  id: string;
  name: string;
  phone: string;
  status?: 'online' | 'offline' | 'away';
}

export interface Conversation {
  id: string;
  participants: User[];
  messages: Message[];
  status: 'active' | 'archived' | 'deleted';
  last_activity: string;
  metadata?: Record<string, any>;
}
---

ðŸ“„ frontend\src\types.ts
---
// Add your type definitions here
export interface YourType {
  // Your type properties
}
---

ðŸ“‚ middleware/

ðŸ“‚ middleware\auth/

ðŸ“„ middleware\auth\app-state-sync-key-AAAAANc+.json
---
{"keyData":"CmK8btCm510oeErD88gaYw7/T9X+mfE8H1E3yNOvR/4=","fingerprint":{"rawId":129812117,"currentIndex":6,"deviceIndexes":[0,2]},"timestamp":"1740004348840"}
---

ðŸ“„ middleware\auth\app-state-sync-key-AAAAANc4.json
---
{"keyData":"seQOw7XYhe29hyJ/mzlCb5p8YCWf0hQrr/mUdiaYZMU=","fingerprint":{"rawId":129812116,"currentIndex":1,"deviceIndexes":[0,1]},"timestamp":"0"}
---

ðŸ“„ middleware\auth\app-state-sync-key-AAAAANc5.json
---
{"keyData":"y3/x8EYpfNpEYolzSTJFN0X3ce7sKcGdFykDrHmSlXg=","fingerprint":{"rawId":129812116,"currentIndex":1,"deviceIndexes":[0]},"timestamp":"1739964085885"}
---

ðŸ“„ middleware\auth\app-state-sync-key-AAAAANc6.json
---
{"keyData":"ZPW37ZOlNB7LAVq2/mgZ1bT568+XGPiC/bS0n4lvbUQ=","fingerprint":{"rawId":129812117,"currentIndex":1,"deviceIndexes":[0,1]},"timestamp":"1739964097902"}
---

ðŸ“„ middleware\auth\app-state-sync-key-AAAAANc7.json
---
{"keyData":"QvDLCGZhK2zrxRpIzKVclWu+eOc7j7nVugqioFPRXew=","fingerprint":{"rawId":129812117,"currentIndex":3,"deviceIndexes":[0,1,2]},"timestamp":"1740004023675"}
---

ðŸ“„ middleware\auth\app-state-sync-key-AAAAANc8.json
---
{"keyData":"jJ55WjehddKG55WT1etX4Ebuyj3+I3GSbwxuxRKBnG0=","fingerprint":{"rawId":129812117,"currentIndex":3,"deviceIndexes":[0,2]},"timestamp":"1740004024687"}
---

ðŸ“„ middleware\auth\app-state-sync-key-AAAAANc9.json
---
{"keyData":"RwBbi+XG2oN77/iJ4RLGsK7lFlA7c2wlXpJZ8CPwtA4=","fingerprint":{"rawId":129812117,"currentIndex":4,"deviceIndexes":[0,2]},"timestamp":"1740004048577"}
---

ðŸ“„ middleware\auth\app-state-sync-key-AAAAANc__.json
---
{"keyData":"siSgPA8b+lSLA6VBIGZnNqoTtIpw04JJGb8z5zShayQ=","fingerprint":{"rawId":129812117,"currentIndex":8,"deviceIndexes":[0,2]},"timestamp":"1740004553837"}
---

ðŸ“„ middleware\auth\app-state-sync-key-AAAAANdA.json
---
{"keyData":"2Zsaduo2kxeqkKrD7Zhso03ZCmSTcd4uh9Sq+GOiIt4=","fingerprint":{"rawId":129812117,"currentIndex":9,"deviceIndexes":[0,2]},"timestamp":"0"}
---

ðŸ“„ middleware\auth\app-state-sync-key-AAAAANdB.json
---
{"keyData":"Q4h9xwreiVbaXQLZg68olOJTOnEqWWLaezfDnAwctmM=","fingerprint":{"rawId":129812117,"currentIndex":11,"deviceIndexes":[0,2,11]},"timestamp":"0"}
---

ðŸ“„ middleware\auth\app-state-sync-key-AAAAANdC.json
---
{"keyData":"v2aHLsYRZOPJui/ZmcKBkJSjGg2Z2VWQSGSzCR5IkqQ=","fingerprint":{"rawId":129812117,"currentIndex":12,"deviceIndexes":[0,2,12]},"timestamp":"0"}
---

ðŸ“„ middleware\auth\app-state-sync-key-AAAAANdD.json
---
{"keyData":"62URFYlK1ui/QNyPSDiVPStdHv4z7ybXzfKEABDU9p8=","fingerprint":{"rawId":129812117,"currentIndex":12,"deviceIndexes":[0,2]},"timestamp":"1740015880567"}
---

ðŸ“„ middleware\auth\app-state-sync-version-critical_block.json
---
{"version":6,"hash":{"type":"Buffer","data":"/aw1h2tS5bc0aoFJEeOxefhxXlirMZYLXRG2pRdSNezvWm6OaVqcALyGB2XXP+KMRbtt2k6Io39VAWX/L74U1yY9LiLEkS3t6KNEgjBenTNkWIprlfRGnNb53QwvcoAKktFh+YHKUC8bL9vT378OdfTCE7qVmWpgNtrvpdTVVDA="},"indexValueMap":{"JlwDvkshb9/+r4KT7ukrX3yT4JQDDFg1hyQsNFP/12A=":{"valueMac":{"type":"Buffer","data":"Onf5/K7BpGIKKw58yoMd/XwEUz6W5Etym5In5T9cXfE="}},"eXbvI0rZqLKaiVvcz5yj50rk/WpcqfIdNy9HIufz/fY=":{"valueMac":{"type":"Buffer","data":"Nh1+N6iC8sbH9o+SDOPWy7OIfw6FXroC0pnNs53amJk="}},"8lbJWzoYXtJls+abHvTkXuwkpdc3fnKaa/hZRzSr0lM=":{"valueMac":{"type":"Buffer","data":"BlOdPWVWui/da8GwLRq2lbafd2bIDGyUrHRHKtIyfso="}}}}
---

ðŸ“„ middleware\auth\app-state-sync-version-critical_unblock_low.json
---
{"version":12,"hash":{"type":"Buffer","data":"n1M17QxICI2aUU1zvd19ICVi8p7KXuEoklrPKyzZ8l3fJnfyGDI1gJrzypDpdCeX0mp3M8Jzo6qdjlsiNzgOtaIcAbD+LOXUkaRJ3OqkSHr+u4X6qYe3l1tt8ajP5FCjitb6D7O6XesZhsVAIJ0zXRUuHD+G17Rn9a9Nt4aGak8="},"indexValueMap":{"AneQOQlDreKp8jwrau+5foaalp9CoBAAp7i2ely2qgQ=":{"valueMac":{"type":"Buffer","data":"9zmXAxWQGOtVxhC3qqr7mcDGwaVpDuNpK17S0MWsKsk="}},"B9K9TqIbknYVD4DGvau+NxtLwgL9+FA89jAokORN4lU=":{"valueMac":{"type":"Buffer","data":"tgkf0GG20RmyDWKw/aq+fVB1VIbvI5ZeRiqFi646khA="}},"CCh8/Fz1GeR5Z00CnxEyWKVFYtfbVYUkRz4N8F87Xfg=":{"valueMac":{"type":"Buffer","data":"OBpRghpSRoL/tFQ5/CQ5Tp/gTxL6gF5101AArQEGFLk="}},"CTX8ff6OeHwKiLUlHmOYg5Pow0i+gwphv0SUIJp/zr0=":{"valueMac":{"type":"Buffer","data":"L0PgwFA6gcGCpZcA99BWFlHAmdejCO+a3h9fmJNX9W4="}},"CoC3eiasaaaoCtOBDla1VNJU6r08B8Ns9y6QxFxchJs=":{"valueMac":{"type":"Buffer","data":"sa1Ov4EnBNZ567wZBum1ikgJ86hjpFqA2HxeOIYIe9w="}},"DmEbTvrKzinVAXtoQOgpDuBkeVT2oDGabdcX8bF1yWU=":{"valueMac":{"type":"Buffer","data":"hIzFX3KDLolMJ2vOxranKzezJiDr4N5EepLeYDvoEz0="}},"D5lknFj4DQA4MegisndpV7gCTd9/E4JNAuFOsQ7V9yA=":{"valueMac":{"type":"Buffer","data":"qO7tck2kFPJjobig5A2pbGE65aibGnA6YGIw4pCtLcY="}},"FUjDAm61/aEMH/xFXYbXCNPyDAgYATKC7E5uHHaYbDI=":{"valueMac":{"type":"Buffer","data":"DZc1zqty44pCbcOlfwxIc2aoERvsi57zHboA9CoDApw="}},"F/q4TtJcqYIszyNBk8WubcNBFutvdESxAukxFPfPbMs=":{"valueMac":{"type":"Buffer","data":"LTKontMU5sCNuJDr7I0hrZqMopjKR/ZQ4N49u5hxWRg="}},"GAKtXPamzpEQ89gnvrrrqjpbrcTJK5et6G7UlontBCU=":{"valueMac":{"type":"Buffer","data":"8xJb8JecYCfOUNJJtrkO8axMMHE8ZPlcOHlppdDwdno="}},"GTpyPe0xAb4CZ1id5szvPGzH9HXCPPAAyZOvic5OnB8=":{"valueMac":{"type":"Buffer","data":"ehIs+EDyfjr1yZ+bXDRqGIU61EamvBit585PV6/g64Y="}},"GmqpI5dnqkikg50A1jAJzj6xUZ2UdobypiGPHkcMTYY=":{"valueMac":{"type":"Buffer","data":"hkeM3eJQ6pM1C3KLuaKbArp6hZTmljQYh1Ph8wK/8g8="}},"Hn27wTyyYJSlVeAXgs817F18A9l0oI9PNLFWO1Q0Sc8=":{"valueMac":{"type":"Buffer","data":"jeJx8kzi1TRyzpQVN//FG+8SIMuhqJFhCL+wR3isYTQ="}},"IAI95hQv/75mvrxcv+dPcTv6LBm5N3DGb11T028XIXY=":{"valueMac":{"type":"Buffer","data":"TFPkKfbFc2uqkTZ0Rs+WnQPweJqnwQKS5a8t4+wTD3E="}},"IcTPu7yYBHQzSrmPzSoewMXhgGsFD1j/XnCjACfuFHQ=":{"valueMac":{"type":"Buffer","data":"CNyyOjKNvUmaEQEEiYmCVkvNeoCt50MG5fC5bac/dPw="}},"IlBrAhCQbFY1BthmSvgic2k3Uwz9Bx2Pf4c5CxORpgI=":{"valueMac":{"type":"Buffer","data":"F72qg68uJYNqzQf+lEQdHiXrqVcK/NheFLX6GOS9gyc="}},"Ip5sR5QO5Yv0YwKRMYOTPCbcge5z2QiznOJQz9JPf4Q=":{"valueMac":{"type":"Buffer","data":"Bpcwe6rRJAFJDsTEjEXKTPcxYB0qF+Nd15zeg4z9FiA="}},"I7D7Rg3LSE1H8aVov2EMKG4TRtThJIudscobTnkuxg0=":{"valueMac":{"type":"Buffer","data":"02duC5qB3HMWh8LBlBC3sNYCVF8pliPmwIh1Gf7x80A="}},"JSwdN1HyhuTh00ACqIRvjhN4VY7G44FNWdkF1FSfSPE=":{"valueMac":{"type":"Buffer","data":"TMeMXIdsI088a0rHSlMoET+0p0aoCiL8w5F8hUtRpmY="}},"J3CyCGkOgRTnVLNbSQVMdnp6pU8lNUhB74O1YeFUvfQ=":{"valueMac":{"type":"Buffer","data":"A5guejOjhtIwwIzvujoPJ4pyC2wzy0CVWdMGTFzylkA="}},"KA5d53cPoAreH8OW1kdjslbPkEDq8Zk5pIUu5OWtwc4=":{"valueMac":{"type":"Buffer","data":"NWFm/BIsb4co1DOuOW4Um37rSFPFHdwKI2GKjUTsozQ="}},"KNnGwted3Pp6r8X8t3Evtln1EwXWw61OBe1+SPTYOEY=":{"valueMac":{"type":"Buffer","data":"bboxf2B2pYnYkdJpYYWfz1k/F6K8mhXkiWxxyF2suSQ="}},"KeXNAl2uDI/rdTwq+bZkb90FfT8iB1UNVn9VGa4no/4=":{"valueMac":{"type":"Buffer","data":"q8WLQDq/Tj0KjtvRzuMxEGlHzYujZr1DVmHUXcrhJNk="}},"MROOiu9ECQOd3gSqhER6+SFnJpdcUwt1eI3IXJu4Kq8=":{"valueMac":{"type":"Buffer","data":"ATJXFfTZaiRrnnBFEHSAi33MuA2ovlszle6J5Reg0WQ="}},"MuUtKUOd5NXxsLJjd1hvEJLZ1ZNN/5jFaal04vM6h7c=":{"valueMac":{"type":"Buffer","data":"0YfvzQ/Vr1PuMVHReANCFc0Bes1PrdtT9KmA64BIy/8="}},"NZWdyHw3ju3CGvHDyuD6Xxd/9V1MJNiVa9aLuXboy+Y=":{"valueMac":{"type":"Buffer","data":"1yvPAzuOuUQhZleTjSuDVa5aamcVdzdNw8UEgsNE+pE="}},"NjZ9PDFQpPldXbQ39UDavTTtpsOPXQE86zVqnc/doaI=":{"valueMac":{"type":"Buffer","data":"cLzU5r28i+jQ+6Fca/v4eUnrwIoQe9tWPAsnwsTjrNM="}},"Nplc0pM6mG1PqXnDPy6eEXMmoso6el+GIcV7cbdoXtI=":{"valueMac":{"type":"Buffer","data":"bvLOlN97bAEDcuvV2bc4hkDFhh6IJ9UPoyJ1v/Z9FtI="}},"Ol1Gc0jzXTvnSG9LL1NtGDz83UW6gsqJodj1oluMubI=":{"valueMac":{"type":"Buffer","data":"oCaJtbBRNj612xBMZgfQL1VqKUQnjxJPAqD/2vhrV10="}},"PFxLKKwZ1IF/N8EsKwSUlQlj0mQcCajQZ49gdJlfvu4=":{"valueMac":{"type":"Buffer","data":"9vyd6rk3qJLhPNRIuLsLzTrJy846XzBuE0YmRK7LTxA="}},"Pgkf+MViQY1Yx9h844/xqeVYByW9iHA/VkTbrk/ITWM=":{"valueMac":{"type":"Buffer","data":"4KJro7avKJWzZAbb+mS/fIXPIvbe8MraaS3hkzmOMNc="}},"Ps12Qc1R6VxB64y0XvRZfWceAtybQyXRRXv3u0y6A/g=":{"valueMac":{"type":"Buffer","data":"xkz5ePvD6oMgCPq9eqHXEwuwgIh93+3WIdN5EpnhkYY="}},"QpgE7tkvvcrWr7uQO2ypK1UeyK6lJ6KNw7v6EYLL084=":{"valueMac":{"type":"Buffer","data":"mapBwUIWEBgS+4JdPqzjDXs/v5blIGoSXhKQncagywk="}},"Q/kRy/p1D5sOwNs2IDkRx2Y/EIRy7zaL6YjnXg8jdZQ=":{"valueMac":{"type":"Buffer","data":"yVylAZ9/uEC11ntqB+0C6uk0VMOUNkOCwfRqaVsM2JE="}},"RJG2NWVQN9TWC92cwHn8pgpvodDkuwaBnknM/5CILlI=":{"valueMac":{"type":"Buffer","data":"5c4ej/zEzRrYAZS1QeagccwNTR3yooK2yI96zqL7HoQ="}},"R6enZd1fnPql1XKeQGSyGrihkdmny6W0re1UJ4SCkaU=":{"valueMac":{"type":"Buffer","data":"+k+RnfwAqm2vzp9ftg5B3LJcMDrh9BJZ4dG8GAQl2r0="}},"SPKKwcyTs0LL2F7cYASYr6FJ8gWiyhEp7PR73+v+JII=":{"valueMac":{"type":"Buffer","data":"5PUnMsuIrhZEwPAthLvTRFEJfyJdVzVPjpdhgtDUeeI="}},"SRnOF1URy/nbTy7XE7Vs2vFZrIdb2vGSoJ8jKIf9o8I=":{"valueMac":{"type":"Buffer","data":"aOnAfu9KVleOBr9ypiF2lwlfeEqcK7KqBErKRrfcI/M="}},"Spyb1cd9JKePGmtZnDN/dAar2sh4vEXSl6HtKpA1Usc=":{"valueMac":{"type":"Buffer","data":"o16rBCvh5UolXN/+hPxrEl8nAfLsDBgKmsLu2oM2tww="}},"TV/qgmvDIlSrB6awm2Ww3l6vhiKuZ6rxT4wjuLEDPds=":{"valueMac":{"type":"Buffer","data":"E9BYyctLMAb1kkBrluSpVqVmpMdAafd7CU/6Ig1b8CM="}},"TvMQt7hf3TbgvZOM4H5bc+QvVxLw2BQPFjHS4lC5Tlw=":{"valueMac":{"type":"Buffer","data":"/koLDebgIxanv1ozTvSBvKAcxa8tG7uLrdx9hRMzj4c="}},"UJctb3qmDugS7rbtbajvagsRXnmuR2HLhnuEkgbDB00=":{"valueMac":{"type":"Buffer","data":"lgiR0CCu0GAcH9O8073LZrEYg0YOOYdqNPHZexortxQ="}},"U40O/V2K74TJDGJs0Of9KVIcffa8o2m0mZUDrp76b5Y=":{"valueMac":{"type":"Buffer","data":"1JcXZazXNPV/CU99igvHe9cWVgBM0lQhJofGzNurJQo="}},"VP3oluC8TQuh36LCSZvK/lmk0YTsFgzzyOfBE/oe3C0=":{"valueMac":{"type":"Buffer","data":"Zr52PQeXs14NRc+BerT8XNslZVdBs/xYuk4WA8Uv0dI="}},"VVXiZc3CQqLyjSJ/BI7kn1cBaKXML/bCSsvCLRQ4nnQ=":{"valueMac":{"type":"Buffer","data":"mouGCSxxOru5VpgxrQPoWkvuGrzFXmOJMkoTCHzwiw8="}},"VZdUxudCb9yJXsyu2UxQmcLj07j6U7ddxmT8ZGWSnv8=":{"valueMac":{"type":"Buffer","data":"rA6vdAcJkL/tWIPw8Dg7gIHDcUiZ523RLsqNdhgsF/k="}},"VbdSCtw5IS1uqMydOw9vJ+WT5mDDrGk1BlyS93qb99A=":{"valueMac":{"type":"Buffer","data":"j1ChsCXO0hq08t5IKqdeVCPxLt5vTh3O7VP6C5v7XpE="}},"VwvzlUM2L2fKAdE7TpucOHV7c6+HagdYxk6Y9JBNoIU=":{"valueMac":{"type":"Buffer","data":"WaL/tO06y+kL0uqBpPA7Gr+T/y3dQwoOcq9MrCUtLD8="}},"V3BmTGq1ziLIiekqqJoodJeBdhETaczmHVI3QryF7tQ=":{"valueMac":{"type":"Buffer","data":"SOIhs5Lb2mrrup1YtSyRhmkfZi0kbn92NAgGD+IePYQ="}},"XcZFY+C1YmJdlaVJjX8+bbIzdeuPbRcBJOLB5YVkJs0=":{"valueMac":{"type":"Buffer","data":"dH0ERgoJm7g5yay9/jAEi8ONI3FkJ+2f/2JTWtDae6c="}},"XdObWc49KPeQcdVXe5t7iCP9XQGfwyr1I9GZyw8P/g8=":{"valueMac":{"type":"Buffer","data":"VSBavjSup/rak9n8Zv61tZOc2nlDO03jYyEPYhLrBMg="}},"XiTDFulPoUCWJaFBgnRHDvdivVWqsd/WyDeCGIRQ5sI=":{"valueMac":{"type":"Buffer","data":"/MG/31sUVozodqJO3bucByN1N29XCM/ngR8xhFttOMY="}},"Yfqq4k9wMAafPOBuQCpx2KDzltZSC6375j06TbqD0IU=":{"valueMac":{"type":"Buffer","data":"DcQ29hZ3fIKhOmmQ1kzLfPtg2gLkVL8Yzq+wTqCUqtw="}},"ZExZnApqaWRxaLpVsMUhwO5ISx/CNir2h/q/5TP3p20=":{"valueMac":{"type":"Buffer","data":"TJmbHEESMGNxZaHE6D9YX/PbiixnH5QgPDFhDEpMTNw="}},"ZYJ7tA15TkDO4b1vHdU30caXlbF/8eDx47tfqlsSMcs=":{"valueMac":{"type":"Buffer","data":"LuJ1OFtMr41xAK8SqTxOEO4UZCA4vBp//t+P2wLcXcQ="}},"aaArUsC7lGgGdV0Uz6MMkMmDEDN5PjZ+MYYWi+/OBCU=":{"valueMac":{"type":"Buffer","data":"ap/pLdEyNrQjmIvAr1QmDEIaGCJynPebzZuV9+9bD9A="}},"cAOf/KTSyFJ48SrBkbY1LhuaF9ODI6d2IrmoUXCUmCY=":{"valueMac":{"type":"Buffer","data":"uc6CQnaWNE1RD5qIgt8pKtVPIq50oEwPGNTxyzty5gE="}},"cbx04uatSMFJn8Pr0/sLdegkHXkuQ9p9/NtM+MFwEwY=":{"valueMac":{"type":"Buffer","data":"Q/H4aL2LCByO1xKLyZIZX2FjLugfJIYX520qLXP2878="}},"cveyyss8FcQC+DnDDmMb+PIEnCYyaQrccyoadzBnbnI=":{"valueMac":{"type":"Buffer","data":"CSepjJGMWIZD8gVEejS5Zemnv3GS0ivCt4SgPX8zAgs="}},"cxb3aeFfYoJWIL387cjMma+VVCJfSlixzOX94AsxfTY=":{"valueMac":{"type":"Buffer","data":"LDU2/VF5Q78LS09++Bb920U5fzhgdkotJhBcVhQlAEM="}},"dRLq4OFPW/XsiU+3bd7GOhYQE7bwevDoZkDZv7vylrw=":{"valueMac":{"type":"Buffer","data":"atlCms3N48TfghSQJpG4pSgPos1+a1MhEth888FhBaI="}},"daZ/T+izuPKUZkpGEC/Gml/T8fSylRREyY44zTltrIg=":{"valueMac":{"type":"Buffer","data":"DETNnO2ULZdGDx/uPW3lO0aGIRiqHvdhffIWC207gXI="}},"depU3AFeFX6u4fAsan7/aV83V/PGcDyLqZg8nvN7mUE=":{"valueMac":{"type":"Buffer","data":"hNH8u85mM05WJotMwRpQuQlJ2SMGyBPaBSE6s3P3Gr0="}},"dz1e4aGGv0xtfqUahCSvKX1z8BKOdiST0t85YB4h684=":{"valueMac":{"type":"Buffer","data":"OlEod/Bnw1id8J1Wr//v2xmqSZLKxsZ41/0gOURVHko="}},"eH8jQXi9++PI3e0qlqA8scnQ7mRepmDv9pMU95Xp4f8=":{"valueMac":{"type":"Buffer","data":"V1bDesJudNK0emlW1I7zFfLW7bYGPLK0hpPFEXkDU2A="}},"eZzy7AomhkymFWUk9BYUYgCJQqla47vFAS8O7b20ZyI=":{"valueMac":{"type":"Buffer","data":"gpSeBghXO24qYnLv3+ciIpBnhFf5TZwVkrM1zXRDa6Q="}},"eii9nam2OhY/ZrKDIoUgjcSmUEA60UbZiqrSp4jpN/8=":{"valueMac":{"type":"Buffer","data":"BOrD5GhYN3gCL5mrMtmGyuDoG83AFRuQRSrheHKVCiE="}},"ekpAQ6WXPdRWmORamDqduradwsIAo0G+h9G9YbZ3+Ac=":{"valueMac":{"type":"Buffer","data":"f74SUMdh2Nejvfkpni7oa2O0+OeHHLo8Oo3//DgYwkA="}},"ewVAWHndZ78dnWpNHiu/tIqrgPZmJO1QqH7tYxa4Asg=":{"valueMac":{"type":"Buffer","data":"EFieav2yaxuJZlYBbmM8nfiGMJ2q2Xb+oxWU9Y6lfxg="}},"fD4x772u9K6nWK3gAy+EjqVfp+y1yOjaSqU6d7yZn8U=":{"valueMac":{"type":"Buffer","data":"6E7Jw5wK8W43MbtIOI1EIlelMlJE2xlEbfw3VDpwEXk="}},"fpT71YGtSRopkzxgtKMqcH+FVMn25qGB73nKJQ1B4Sk=":{"valueMac":{"type":"Buffer","data":"XhJIfmxcSO6YwVDpHDf1hk6JzGJsxxWUVku77lGH3v4="}},"f47PSmvKv/wSxGIm4Fjvd84EkrCqhsEaLMlhorUrCsE=":{"valueMac":{"type":"Buffer","data":"igVhih4of3/UxWhmnXiT4NLy60UlslG2QEOAryxvMwE="}},"gArVgNq+PpPfSb5dx1a//jE9KMZkggHKlS5DHAKmkBA=":{"valueMac":{"type":"Buffer","data":"mP3+y5ECGXGmLwknNZcWBqDi1aRHJTt1raVgf3P7w0s="}},"g8FTAgXu2GzVbKDLaFYxYE6eeWzJHys04kgeXJRsMS0=":{"valueMac":{"type":"Buffer","data":"STe38EqFtYwTKfE/xr9SyKdSFnojOi4hQ1iuEMY8qhY="}},"hB7Jq+qKvBUn3HKSk3ScMfL+HxmsDAoQ+/u3OIcr7M0=":{"valueMac":{"type":"Buffer","data":"igsW8pfYckIZA3DiONiYm2Gd48We8VJb7TqxBZ9Hm6E="}},"iJd5Njux2m5NbdIjw88oRwM3i9EPiK1uwNkBaCWko48=":{"valueMac":{"type":"Buffer","data":"x3pIVe+xaXSjpIXwtW0xKJfLw7/fLE+SCGYVkZCCPIE="}},"iMllr27gB22UHOvlDGVbFcCPDL+emYsR3ZkfBL5Upq0=":{"valueMac":{"type":"Buffer","data":"zqjWjMPc3sjvlloX8GJe5mCAu4iD9cqVkMxUQkj+pks="}},"iOhGE8yUmLEJGdpLkTkKDYuJos8SHsorn6jbmlLF71g=":{"valueMac":{"type":"Buffer","data":"atn3nExiYJvV9aLV5LcM7c5/MitgZ4vkCKHA4nMDwp8="}},"jBNsjg0S4fnHjjsl9vxUmuuV4jNY0Mge07q0IqChO2w=":{"valueMac":{"type":"Buffer","data":"UrThqDuPRd7Z3zMCQWF/ugbM4LUOIVpTkVzMlqs9KRs="}},"kW5g5dzhkedZVlXbR0Sd74Cb+fTH2Yz8QD9I3jrv4xA=":{"valueMac":{"type":"Buffer","data":"AyQFGcxfrZMrK974Fj5SmyIm312PZ3tzhyZNU9X/X2Y="}},"lPMW9JxYn70kvjUP5q13gGU4E+RCW9YOn2/t2yxPizQ=":{"valueMac":{"type":"Buffer","data":"FQBiVF77P+YqU+/TZPkbe6VdyJ/XGMmSB0F7kShEtdA="}},"lqHibSPBnklSw3abJhvZZyLKCKA1UPe4PXtx3ZC3cao=":{"valueMac":{"type":"Buffer","data":"hXh5zeYGtDtoKVEuxICWJ5jNTYMfQxdkO3oYrxzyufU="}},"mRebZzNA7xz3uy9Qz2lU2fWABPjwheHJfbAEjgKptAs=":{"valueMac":{"type":"Buffer","data":"EK7/kPvtBHrl4tdYmrwlxo11roH4ExO7HufDDTUC4j4="}},"mWMZrjqa5WfvJowEoOXqpIE1209QoNpGnx5e/V7rW9g=":{"valueMac":{"type":"Buffer","data":"gG7MDkJMhV/QSv1kXWdupgsNT2p6/Xj7MVhT7NX2P5k="}},"maKZX1MMfqVBcrqPMjZQt+pDf9UvStbKivZ4RCjnzq8=":{"valueMac":{"type":"Buffer","data":"C1/qkmZ489aryzwvj14Ker7H1/dDHGB2vacxYICJWyk="}},"nPCuq3wm4KlKfMt2qfsYnlte5Oj7l5oOKWlYipKCke0=":{"valueMac":{"type":"Buffer","data":"9p8fJQuSuFt/mX0Dqvc/0bGJEDk3oVwrU3tzumN+474="}},"n1RJO/6+0TlUV3UPhORhoNX9KyNekT+iIOQMdApTZ3w=":{"valueMac":{"type":"Buffer","data":"6m4aVsoRrdu3SKxByeaIyP4ZyfdIAhE/P8EqpYXCLpw="}},"n9qtWem0SPdAQ4xNq5HK5ypg4WnVYxb7T7RywVpAMjE=":{"valueMac":{"type":"Buffer","data":"oCPPP4XrnehyVpcaRtZMGgl7krSM2kza2q3Ba0AOCJs="}},"oTeeT4gCuEdBLncpVYuRM5nYYcLk3Ooio1DqYlfqO4Q=":{"valueMac":{"type":"Buffer","data":"tdykS0ARnlSZocECFn4gCD+fXKzbz9DsKrXNWLP5vIU="}},"pC9XI1gJHsBwkzrlhAeahXEh72OiGE4IJo/jGIHfwy4=":{"valueMac":{"type":"Buffer","data":"lyGIN4renTHWW0q5o4pUPUB5b0NZFgpf64SvPZscQfk="}},"pcYpr6X7ROVOf4poH2wTjSFHpiKcLEbWJuSlH3LZoos=":{"valueMac":{"type":"Buffer","data":"JKuJmHNayreXau2myo47wxa1bo9acT5nRxV/bsV2UHA="}},"pw3rCv3uGCN/HHyjXgiFmYpw1GwcazEuQDAN685v6q4=":{"valueMac":{"type":"Buffer","data":"eaihP0YSNZEx9xY8qm6/hthktPTP2XsTL/ZndaiWysA="}},"p9+ckb/qG0cs7pDkLZOJ5rCj+UQdBqFOPzCwQ9Iw6rs=":{"valueMac":{"type":"Buffer","data":"c6POk1R4vi24XpdRhAkkRJBAzo2MKLWy1haTsWNRpPs="}},"qW8SblW9EaWtncP78zWemJhUsgWjxjMM6uRo57VxtAE=":{"valueMac":{"type":"Buffer","data":"MpivqbXgyveDm1qQOhKQQ4doqFJh3pdHq6Xci/kJpKo="}},"qlbbIEVA9iTV4EPkEpxVmZmvgxfLNWkQIG+8vwi7kJc=":{"valueMac":{"type":"Buffer","data":"ixu6JPWXANGpEX/m5ubOcmNl0Z+yOhDJQYJR3nRhUqg="}},"sV9uqAYKH/+3FFnHKYVmACOE9DKhz2WOMSFLg6dLpmY=":{"valueMac":{"type":"Buffer","data":"ix8KjXUff8tlU+MmbP7en+lY3ksWuLy5nbL9JTfZ3Ls="}},"tASM1VEGWUjmpX0M3TKFMbUUwZrDK/yUN6lP1MHId48=":{"valueMac":{"type":"Buffer","data":"WPAe0KbaWSSrOGMH0xL3SVwkleIywT1wS6ZarrEiPzo="}},"tHhEru0oikK5zNCHJcuc98zTlY7AvvlbrrgM8kKhHL8=":{"valueMac":{"type":"Buffer","data":"D9MAKa7P/EZNzHWGxWNQ2aWJuGQzGf1X13FahdgSF0s="}},"tXOtDY4n1S2IObLw7VOopZGSo24D6sWliTxK0rcFANM=":{"valueMac":{"type":"Buffer","data":"EKyB1+uMQFwCocwE7tjNbEpwGYDoQrBwM1nv67jATNw="}},"tr/YkDUHo5fKMCFseJouDduBTjAr5Rd3TrRSd1slRD0=":{"valueMac":{"type":"Buffer","data":"+154s1WEtCkmfIv7uPVOG7BtE/feH2gX51+COswIUNY="}},"t0IOxTDdDzYg8R9ExarCu817308f60cjqHvvt7hAvYI=":{"valueMac":{"type":"Buffer","data":"lutfckEgf/tp/0NGSMh+NR6hNMiFggmH1cekUNiMLmk="}},"t6YXGTLIUqqJm4stVjpadXEl9FQt2KwfWZ0gx1zdHpM=":{"valueMac":{"type":"Buffer","data":"1g8am62wy1XW0gujLMX30caF+bDjwoY24vP3xEMh3Dw="}},"udn6WX5xp04S/qeTYkAYUzSuSme8GDUIfbqgGXtd+kQ=":{"valueMac":{"type":"Buffer","data":"Q8rEfkveP73rIXDMMXzRtQ04vE7k5lVJv95WB51NAkE="}},"uhr16u+ivpCQDM9SfByN1dffSMvqQWHLEh85GMnymLQ=":{"valueMac":{"type":"Buffer","data":"n7YNwrEB41z3gFviAM19/mlbeAXinz7ZU8EltqC76Xo="}},"vVlVvQFTCOzgxCl8ekZ7I151I847MvNTv0Mq6afqSEs=":{"valueMac":{"type":"Buffer","data":"r8zxjnS6j2zfHSFlpHUDa/88w45jPO9Pz2LfMEthxvU="}},"vb9e4mq7/6ske8gr99tMQd0b9qv/trQ6sFJCdmEnfYc=":{"valueMac":{"type":"Buffer","data":"etqW39xxrat+2SttM19klApgwKlydtkZVk9GDWj4I2s="}},"vfmlkZwcpKN4kLc+RMHiUAgJsk+sJ7Euz1x4Nq6aVtw=":{"valueMac":{"type":"Buffer","data":"Qxzdg0Wq46y8QfMJJcosObypJMwUzV6TOibP+KKhI5A="}},"vgwubDIYLBzPcSv1OjWc6bTl1jxpb3mzYGw8ONGN+8c=":{"valueMac":{"type":"Buffer","data":"lw68dcl6KGO9ycif/cD8/dwVxZkh0sL06CXdG8TATSE="}},"xTFE/tgrqISdlmMVXaZDloNaM/w/zawxCPT1HUsYTiY=":{"valueMac":{"type":"Buffer","data":"XZZB8iBUeqAE4z7QtUW7IGgeB0xXHOVogImwne0aVhA="}},"yXF2O/JGxXPixCWd3knb3ECqNvN15iwP26GapCbl5I4=":{"valueMac":{"type":"Buffer","data":"/uEEt0jTLIeagQePI1F63pP1VBmK0nNTqGHn3QIHcrE="}},"zuNDVgvQ650LOBBHqpVxYdnzwkKCFde5mpAfGZOPVhY=":{"valueMac":{"type":"Buffer","data":"XIz0aP4bE4lrun0crttytifP+baMY3MY65mGJiWGeOQ="}},"zxduNessxiXGNDb/dWxOJznEEy0HTQPPxQliZGqyoto=":{"valueMac":{"type":"Buffer","data":"YiA/4VDSNAzReihlRji0ZGHT15OVt13PBqiwpy6MXxc="}},"z4n2Ah/jamk0Q4SmCQ8wh23HGmA1v4ZF2Kcmd7EqAoQ=":{"valueMac":{"type":"Buffer","data":"5msp2JZV90yoxw46OjASrWG5FzvXde+KGA07x8kptrs="}},"0RnLEgBDPpcYme1u2koEH6Q6yq4RjswiPkUZ/96DKEI=":{"valueMac":{"type":"Buffer","data":"RstWBFN3Uee4VcCeTcUde+CiFiaKv+1bjNAvxCqYBRQ="}},"03e0a8qDjjoxW0y7vQYjahJj2WXLu3ExH9aqt5jlLrc=":{"valueMac":{"type":"Buffer","data":"V+uFfuWY2tZnWxJx/mUH3bzSM1fI8oECGhiHuNb+Arg="}},"03m+VgDj+Qp0MqwNQtbitIz2RxTp4gpaKt4Yqh3cfug=":{"valueMac":{"type":"Buffer","data":"GVPLXmSDZIt8CwAlePLTd/NYwMgiYKT/mpBWKEsL6Hw="}},"2XfOSVXCxN1Yi13UMFdD+L2clIrglYEPhh1HSGOXFJ4=":{"valueMac":{"type":"Buffer","data":"9+Km6I9vtGxx/RP/+Ww4I/ZREfEEB0Ln/1BRX4dWWg8="}},"2gdkqmciqLRj3S9FQ2nDlUEMj19hWaphqjgvOI3LkNI=":{"valueMac":{"type":"Buffer","data":"LFTN8T7cFHKJVcQ0RgYrLlXWQuWtyzK4rKDdaQL+7ak="}},"2hI6gMywgnFyVjTTZUIP9xfBge4c3XgljZcwuiipSQE=":{"valueMac":{"type":"Buffer","data":"KwqymS00om2zt1lpImeV5r4AfjUe8hRRsxF23dMHexA="}},"2rO9KJzgHeH0tJtTE/yiYcP7kn1bnE5WOqdt6OUhYr8=":{"valueMac":{"type":"Buffer","data":"TmcH4Mpaph0I2vdlsloRjQM5bReoPYOZjLgfwrWfqJY="}},"2yhxZdAHdKE9/lfCF/Y+O9G/gFaF4XycycIzC+wkCsA=":{"valueMac":{"type":"Buffer","data":"gMmRsfLjUgE+yIKmw/LAlNa4IwqXxpL7qi+RirFnc2o="}},"295THodbBEMRpv7AhgdI52TpLEmKcFzLYNbje+yLOx4=":{"valueMac":{"type":"Buffer","data":"yNz57xXCr3GmsWpqDVK0G92RlbrHUeiH+M4pL+Hbi70="}},"3CrcAuxtNfcOP3PK6zObtIGyTLz0PdB5J+x2zLpG+GM=":{"valueMac":{"type":"Buffer","data":"loRSrJnu/kAPrvPzmHabfWD/w8y6bsWJ0rSE93URSVw="}},"3K9m6L675VScjvZKUvdx9vJXXe1ULua9CrOdVXKfUdE=":{"valueMac":{"type":"Buffer","data":"7PhezLJIVo4F0oFN+VIz8O2gkWNwvRmdVtrhAPniobY="}},"4EgDu4tkOn+yVugGMXASRLw05Rez7LaruC3KzYSbOtc=":{"valueMac":{"type":"Buffer","data":"NT33S/VyOCXJGMFmZd96eZ2TpTNUG6uomOPxOUrmVoE="}},"6exVbLKRfv5E4hlqkzf/ugBEYyZhElqRUTWmUBaD9u0=":{"valueMac":{"type":"Buffer","data":"a8R0xtUIi1Dr2aS/ErwA40zsIeS6ctDs/0MyLuehbEI="}},"79CeUao79f1IRkAhwS0ZK0yMpWehMoM+/ncXbpA3ETk=":{"valueMac":{"type":"Buffer","data":"4uibQ03bKDcp4JAKOs0MyLJW9T9u8cjIMKqJEuRjwRA="}},"8G6C8eURAvGOtAXeBWXAXWtoMU4SNV/uSVKxisNGjG0=":{"valueMac":{"type":"Buffer","data":"xcNS61BKS9tmkgXY4Zh1Et2cWksD3anTb/fWHCMiOg0="}},"8kwpBv+iAkG9CDXAaejuMe9uKIp382IbZB+ZEC2yWjM=":{"valueMac":{"type":"Buffer","data":"whnDC78DgZHJCXPn4bUiOc6pknZCldsgHbAIKNCyAhA="}},"8/nsFNM2TMqpoQ1xOO2oVD3UDA83ITFG/9uqpUrJfCA=":{"valueMac":{"type":"Buffer","data":"3tRWjdaaSwXgwbz2EWLbSczHiBSn/rCGkMOnB+l5lFc="}},"9jOoNPCyDgKfSvVYOWUitrQjd34b4gl/PD3ieHVD/xs=":{"valueMac":{"type":"Buffer","data":"wiJp4gk2XIV3hyQyf1uiYCyekHhoABXn4MToVulx+IA="}},"9s727OAdyfAg/Q0Y4SCZLMyWBflO7/AeAW6Q7J+lXNw=":{"valueMac":{"type":"Buffer","data":"f3qfyhXDf+W92+pmUzjTqbYYzYRHNeYqXzpt3x+zLSE="}},"9wRu5n48X4yEF2g1JDhDYohiFHusRY3W4FOmvdcGcHk=":{"valueMac":{"type":"Buffer","data":"2VeeaJFIRRUOWMXegGXVEqzBdCB4cegcTSeX1hezc7w="}},"+R/EofOlRRyBmhsEVDrBSOQBHJC61v/G06kVw+2hkhU=":{"valueMac":{"type":"Buffer","data":"K8KyVKJaLnUktidxA9B5evszDmzaronRNVlHgg2ieVc="}},"/LCDSZnZUZ39Q5zgMvXMugKO2Sc0L5ct+r7Qb1A0fgY=":{"valueMac":{"type":"Buffer","data":"SqH+QyUJxolF32Nthk8G7fS2dr7g/xnjOufiq4b0lzM="}},"/WQdpFFI1Nt+H88NUgAySlE1QDBCWFzAPQlkZWcD7Js=":{"valueMac":{"type":"Buffer","data":"CZV8Hh8cGcoiFgIMTfzhVcT22ftecluGCbWoJ0Nql7o="}},"/hCeyX3fhlVTkmq2F2UcC16aFFJDiS2MVXhbaKxGCV8=":{"valueMac":{"type":"Buffer","data":"6tkt65if/WVrw2eXLtAjCeMUQxmAK4Fx2Qlg2qbDv/M="}},"/9X/9biclopiLh7pcGOXCIazN+kAwprAj5PY4vwymOY=":{"valueMac":{"type":"Buffer","data":"0O2Yqkt1y8lLiatWRLbxqS045lfuf7QcIH+GjDEFzoM="}}}}
---

ðŸ“„ middleware\auth\app-state-sync-version-regular.json
---
{"version":25,"hash":{"type":"Buffer","data":"7lvBxSWHnLjt65E0JDhCcKD+Y9tTESFzsh5YB2D3gJ75MCNJhBY4Zi4CiiA8DW0rgQnL09XQ/ABjkdPj36cJr1z1W7kZJVZCMTCKPxeImyGZeoASWOn/WgKhg4ZCeiQbAJ/Sda3/qVQgQHS4gqJmyfEcY5WlnqDjhOSwJMpndqs="},"indexValueMap":{"UiFB48OwDp4bLp4RMvya/9HBK3auShunVPZFY40vJ1A=":{"valueMac":{"type":"Buffer","data":"AR5TRkfZh/lgTgProiyvyGbYvnTpKbM8BbBPmic3p/I="}},"VbsfnSn71dB7Oc3DyTYx8+jfmDAs8BDRQpeBviTNBf0=":{"valueMac":{"type":"Buffer","data":"m4DAo3S2wAhVM5vbMESGkyNbN/9PqBmPwnGH8cNjtf8="}},"yMNo0W3k/5S6UyBovBjYdLxxAxzN04hwoY6f36xZG9c=":{"valueMac":{"type":"Buffer","data":"uLJFCLbVDbgsy6g71WoH9716eVgWqRrz9zviMn/lQ5o="}},"0pqTpEp/uN6tINRNQSXDBWbX6ekaNXfxaaDbuEJelqA=":{"valueMac":{"type":"Buffer","data":"8H4McEUhBlsU23WYyKW8x34oh13SQDo0FkQ2FP3OwzM="}},"2gWlbRkihBUbjZMOPWUXcgIimLdvfz+mRRFgi1hF5oo=":{"valueMac":{"type":"Buffer","data":"hVONwCBXR5yGiDWRPA/A8ryiGAXPkBvGhDD6LUDwY1E="}},"2qhMfcB9q4eKPmADuvJhnKM+SF0OdzO0QSbo1tmF6So=":{"valueMac":{"type":"Buffer","data":"5VqH9vXYyQijQU1lZIJKC/m6F0ds23YIQYwNPspBECc="}},"e6XLYoOJhU6lMqSPUUe0GkYCglwASSoMFp34JlIRLB0=":{"valueMac":{"type":"Buffer","data":"HL3Sq5r+4Ll3Ld6QjacIOtFmAqGtXnFZeo86k7LxSD8="}},"kViEB2hBmNA6+kdWvQmioJuDqCqQ3egkF7qxJB8w0qA=":{"valueMac":{"type":"Buffer","data":"/k6rZZpAGXMjjDhDs+d6G55D1pKhaqk3CUYeFKBevPs="}},"Qp3Fbe3yAEOvwLCkaHyiazDBOaYh4sPDBFQI7XBsdMg=":{"valueMac":{"type":"Buffer","data":"DOkScaTVylGt/NP5y2vRhiT52hwtpdjRkingb4ElZ5E="}}}}
---

ðŸ“„ middleware\auth\app-state-sync-version-regular_high.json
---
{"version":6,"hash":{"type":"Buffer","data":"Q1Awe2sxy8wgJNBtjzJTC0/pzQ1X3SEEHfcgnWMHAKo/lzma9/i+D9TEsuL0ZmRcoTrq7sW/q8cEjAu9Am0CHM3cP8JjhhJAS9fIdjfLAHPg/o7jNvMs4PMYk1tQ0869Dgd9L1RSIOtOzk5noOi1tdvNFlcPwun+j9xZnTFwlyY="},"indexValueMap":{"TJ2G541Iy220vmKrBHsbwvGgyskfXX14ZiB3Te2lUVk=":{"valueMac":{"type":"Buffer","data":"TE0fsQ9kS2wiaBr3EqsVa9LbCW49snQ+TdgYGjLOcW8="}},"WXlOD9kPF+1JrEn7qPfOBJuofG7adMwWhhlhr3mtmG4=":{"valueMac":{"type":"Buffer","data":"u03OCrivETKNaNzQX99Y+qev70aSZB3f32DNDucBmr0="}},"eCGy50wHS7uxl0NO/KjzJ2sY3Wmr5H3vTI44UHr2AZU=":{"valueMac":{"type":"Buffer","data":"q+A29OFcpQr31Mt7849OCO2dVgesqw2QPTWP00NORbs="}}}}
---

ðŸ“„ middleware\auth\app-state-sync-version-regular_low.json
---
{"version":21,"hash":{"type":"Buffer","data":"UhsCr9Xy3UMoge+IuBeYvRFeQthNsyi/RC+1USGsN5shoAIgJF7Ar4ySPGEMSOS1TjZjsYG/y+xhvZb2yiJBBUYvphx/W5KCL5adc7yr7iBJPCmeNPu4NQJXgFti1hY9FJmZUJ915CnUv2Z5vXLhhHkDxmQvErgyrpgvnylaNoA="},"indexValueMap":{"RaqQIi9Bz3GdSuV/PNZiRwglEXhOqTak4+60/MjrPTw=":{"valueMac":{"type":"Buffer","data":"+jwNP+bokgoRrdTgvE5FqTCHOIchsvi7sDUxdJvajfs="}},"Y+3YEy08T9F3NBU5oXuNlUkLex56P1CdWlWNL+8n7hI=":{"valueMac":{"type":"Buffer","data":"q3245KkOCZ0S3ZdBVoSDRbXdrxNqcXszwTymt9VWGxo="}},"isIlRMeVx/O21xOPURCZTs7g8a1BZx6MZOhZoczlTnQ=":{"valueMac":{"type":"Buffer","data":"UHTSvwqW+A8sYHVZUOwme4Ou+ycybQOqdSqIqmL3u5k="}},"nM+XHe5u2cLhPTXrEw0qThjrOjGG/B//Hz7/3BDiB5s=":{"valueMac":{"type":"Buffer","data":"HoOa4xtklBaMaQZdqQQxHCnHaXiqnadBcz4oAoy2qcw="}},"1Ola0r5oW7hy/iguFI+H/63YdogauQSvzTNx1edj0jo=":{"valueMac":{"type":"Buffer","data":"wicY0ZzQyCHRyDAkaBmEUHEp+KoW7nlDRgR46EQmPro="}},"/RWFCCM8WziHnXznbmnqr2Y0D7nRLJd3rHagFe5+NeM=":{"valueMac":{"type":"Buffer","data":"gLdMOzgxXx2UPz72KYOEfdeMYsbVV+H7UMimTIKelg4="}},"MAP5GTyyoK4C9ULRx2yb8H3H3RJkO5DrsGNVgqnHYwc=":{"valueMac":{"type":"Buffer","data":"93xo8PMmI92aZS/YQ7/ebTUwlBXgIYA5UegpwWqCsbg="}}}}
---

ðŸ“„ middleware\auth\creds.json
---
{"noiseKey":{"private":{"type":"Buffer","data":"QLd4dxGxk8m3XoqHK1LiV+yIqoqndGcYZVudP7zLi28="},"public":{"type":"Buffer","data":"eeHV1JQPWd4EY7zuVU0p3Ups2Xo8iJC1z4dGrR/CtW0="}},"pairingEphemeralKeyPair":{"private":{"type":"Buffer","data":"QIL5Wa8RzczvUDgSHpgmtfdFgMk61UOXD1TY2C6513U="},"public":{"type":"Buffer","data":"a2myjV6QSUPzy1W+PfwHYmccvNNVmUjhnl1SxMOtawY="}},"signedIdentityKey":{"private":{"type":"Buffer","data":"EOXxyxp9NohybUavEMcdY43KxPDbyLaJG2p/DUbt2ms="},"public":{"type":"Buffer","data":"/tFYeQcmH7l2XVsOTLrkFuvuqps24HS39XV/EGsJACU="}},"signedPreKey":{"keyPair":{"private":{"type":"Buffer","data":"WK07WXzn6H1tTyXdc9Yb58ObsYm+Tnyv07xEZz31g0M="},"public":{"type":"Buffer","data":"cWnCi/WdtXigp62HmMjJvY+yIVclwnA/OpSz1GFp72s="}},"signature":{"type":"Buffer","data":"fbEusBfCxq+0lZy7zF5aHALkxreQcWaeaCkSRnkGMTp1s8Xq9dSC+dg4/nD15boAG+i87Hd+WUDdl6nce1rnhg=="},"keyId":1},"registrationId":66,"advSecretKey":"gbhTVgGgHgnMREoxQ1apjKD3DZud6G2qcFrfCnPFAN8=","processedHistoryMessages":[{"key":{"remoteJid":"51928241365@s.whatsapp.net","fromMe":true,"id":"88E8D449B996FB4033C0F205624C7EAD"},"messageTimestamp":1740032100},{"key":{"remoteJid":"51928241365@s.whatsapp.net","fromMe":true,"id":"A53ED2D7702834EB718DDDC902967C9A"},"messageTimestamp":1740032100},{"key":{"remoteJid":"51928241365@s.whatsapp.net","fromMe":true,"id":"34922B9804C7532D29AA3B051AC37A32"},"messageTimestamp":1740032102},{"key":{"remoteJid":"51928241365@s.whatsapp.net","fromMe":true,"id":"D6BEBE8CDBF84885DB416BCDE66DDD62"},"messageTimestamp":1740032102}],"nextPreKeyId":31,"firstUnuploadedPreKeyId":31,"accountSyncCounter":1,"accountSettings":{"unarchiveChats":false},"registered":false,"account":{"details":"CJWN8z0Q35DbvQYYDSAAKAA=","accountSignatureKey":"6477Bf/N3wA3w5x1CEOyP5IBX0vFLcw4/5D63HUhvE4=","accountSignature":"zKpnXIn1Gfn8E7YFD8+C7NbGsliRZIC2FXQOwS9oZ0iqQwQ/MokVp8t2GEA36p8o218DwbKT00KKDCtCwfm/DA==","deviceSignature":"eKbJziMmPBhGN79dmOX4ycNILmZRUuCxiF3QILANCL76zZEavPJRblXdwlpSOD0+7qb7K2+46wR6hOxt50n9hg=="},"me":{"id":"51928241365:11@s.whatsapp.net","name":"Recordatorio","lid":"278253868724470:11@lid"},"signalIdentities":[{"identifier":{"name":"51928241365:11@s.whatsapp.net","deviceId":0},"identifierKey":{"type":"Buffer","data":"BeuO+wX/zd8AN8OcdQhDsj+SAV9LxS3MOP+Q+tx1IbxO"}}],"platform":"smba","routingInfo":{"type":"Buffer","data":"CAgIAg=="},"lastAccountSyncTimestamp":1740032099,"myAppStateKeyId":"AAAAANc/","lastPropHash":"2V77qU"}
---

ðŸ“„ middleware\auth\pre-key-1.json
---
{"private":{"type":"Buffer","data":"SJwpPP8qIMhnvOri2ScPdXiuNDaWxF1p05uwMShDO1o="},"public":{"type":"Buffer","data":"75pccP5jKqDoCmK9fn9YEImxTMaFIjfMWjjvAmY8Tkk="}}
---

ðŸ“„ middleware\auth\pre-key-10.json
---
{"private":{"type":"Buffer","data":"4CItk5YuXeFlmPWXAqHff/jhXAIrHf/LmABD5duakkA="},"public":{"type":"Buffer","data":"H27Nod5oIrSJkpsA5pvJmdzjH4E+GjCzci51k83H20g="}}
---

ðŸ“„ middleware\auth\pre-key-11.json
---
{"private":{"type":"Buffer","data":"QGJD6EC4emjJAh85zBzxMVBvzTpM9P/3q72+LKwfJHY="},"public":{"type":"Buffer","data":"M2RZZ5eNfJZy5wEVw+9RMrk4q6pLD2W3tWkyWExQO34="}}
---

ðŸ“„ middleware\auth\pre-key-12.json
---
{"private":{"type":"Buffer","data":"YOKbIzcsri0TMFeDR8LMfXAO1UD7VWFCtAcBWSFdAWg="},"public":{"type":"Buffer","data":"CSfdLN8Na7RwSc3vG9diGQpFti35H8l/HNbnwic0o2A="}}
---

ðŸ“„ middleware\auth\pre-key-13.json
---
{"private":{"type":"Buffer","data":"+Csxbc81Cm8UImEl83IQM/CsMQilwDdLdRKv5qj7S1M="},"public":{"type":"Buffer","data":"hISpn1FlykSYlndsL4yPpkVuiT5XSY3I1TWU45GIIVc="}}
---

ðŸ“„ middleware\auth\pre-key-14.json
---
{"private":{"type":"Buffer","data":"cLFu3/hrRHrshQitEHoyeJyI0pRquvqm5hBPKybfo1k="},"public":{"type":"Buffer","data":"nH4ljOz1nsa9P6gaiuhmlTmOfFCE9xmpEAOXvIyF6kc="}}
---

ðŸ“„ middleware\auth\pre-key-15.json
---
{"private":{"type":"Buffer","data":"qKR8SMhMc15dgmWJep8wNi5MSHyDpk+o6O9nwhqFLFI="},"public":{"type":"Buffer","data":"ff7Gess6Q6JbVpBdxgE17dN6BCzOdVMLInxcbw0KvGU="}}
---

ðŸ“„ middleware\auth\pre-key-16.json
---
{"private":{"type":"Buffer","data":"QJgxLNOn/WuY/ZotJ0beIFCb8yolVgrBJIAVJGOIR2I="},"public":{"type":"Buffer","data":"WbuonItb9EIuKnCvCRQ1Q3Xshz6Fc8WeUqrek9hjggM="}}
---

ðŸ“„ middleware\auth\pre-key-17.json
---
{"private":{"type":"Buffer","data":"IKt1arB0xsfRoE5nsWE9I4/YFP1x6VKeTatCHfI6Qlg="},"public":{"type":"Buffer","data":"sbme8GAH2xmFMdurzfZh9emnX/52h2rSQNKgdH1Ckj0="}}
---

ðŸ“„ middleware\auth\pre-key-18.json
---
{"private":{"type":"Buffer","data":"qIYv5qi9GifKk88x6cMymh0Tlj1TYYaUksXRZv79unE="},"public":{"type":"Buffer","data":"8MG8quVrVapw4PiHjdRpXBLSgxTGFaC8dYFDICRAkWo="}}
---

ðŸ“„ middleware\auth\pre-key-19.json
---
{"private":{"type":"Buffer","data":"UDunUzN7Pm9V8Sx3tGBpjVQVUUh4wgZjwT7lnQvhgGI="},"public":{"type":"Buffer","data":"ougEyL203N9mxZAJOBcxNdZvlRTBCUTuNtZJcCaCOFU="}}
---

ðŸ“„ middleware\auth\pre-key-2.json
---
{"private":{"type":"Buffer","data":"OHZny96lF47AnBX1UXfwz1sfbJhHVeC3Zo4AMYtzSHQ="},"public":{"type":"Buffer","data":"rihAqr9yQpt6IJwg6GPw+3aRAWTqb9uKX1B1zwATFlg="}}
---

ðŸ“„ middleware\auth\pre-key-20.json
---
{"private":{"type":"Buffer","data":"CA7HjmkfDztCL1K2bRS//Lv+gviCZnkfDRvc9pkpf2E="},"public":{"type":"Buffer","data":"wle+BSunCZK6CbMvyn+k4eVr6zG1wyY6s2IDVMj6zU8="}}
---

ðŸ“„ middleware\auth\pre-key-21.json
---
{"private":{"type":"Buffer","data":"2JlWXAmiL99dralEqL2L4tx3Lu8updV3DvoEArWdG0w="},"public":{"type":"Buffer","data":"MGUK/6wJH1/0jH6rs+1kJSD7ru7RakAMBJa7cB7Ivys="}}
---

ðŸ“„ middleware\auth\pre-key-22.json
---
{"private":{"type":"Buffer","data":"OBUUAQSP1QfL5rlDWfu9ofGuzq7hLFzQeraZBRaG3EY="},"public":{"type":"Buffer","data":"4a+g3dwRJ2JNTSgg2Q74RQclCij8qhMOTOnOXavr+1I="}}
---

ðŸ“„ middleware\auth\pre-key-23.json
---
{"private":{"type":"Buffer","data":"mM8ouhH/hx6I5ZtGAusCotmaTD6fvVsLeewZEM5Oym8="},"public":{"type":"Buffer","data":"4cW5FIW0UHttJxhDJYlcAovk2y5pl5Zwo2zADwSHWH8="}}
---

ðŸ“„ middleware\auth\pre-key-24.json
---
{"private":{"type":"Buffer","data":"YPz0oj2SS5zIWMx7LnbJyTcg5YMsT8BqIuLRttgffVw="},"public":{"type":"Buffer","data":"qD+7tvh2nUuLpQwFijch/FF/sS6blanKWqAFaCt/+Fg="}}
---

ðŸ“„ middleware\auth\pre-key-25.json
---
{"private":{"type":"Buffer","data":"aNJn4PVnntOYGyHnOtLZ1PXA8xeCNzB2PHRhO3URlms="},"public":{"type":"Buffer","data":"ExnTtRzUYGzYoGseONA6LVwF4wfaz78yk2SNwJLSRXc="}}
---

ðŸ“„ middleware\auth\pre-key-26.json
---
{"private":{"type":"Buffer","data":"0OFdhqy0ot0PbmO2qPU0/s2nZbiNl8dTZU4BPIpvu0E="},"public":{"type":"Buffer","data":"DmqP5QeagzcofCdM9bZFfyzxQt7L4TLBf7GgwRm0/jw="}}
---

ðŸ“„ middleware\auth\pre-key-27.json
---
{"private":{"type":"Buffer","data":"QMmNhAO8ygp9vhctPXlXmkuS9WraZzg+fdmHAS89Vns="},"public":{"type":"Buffer","data":"/ji/q81zKQ/+1YYteLn8wknTOLfTJKbz/OI7qyp+Zls="}}
---

ðŸ“„ middleware\auth\pre-key-28.json
---
{"private":{"type":"Buffer","data":"sLnXktVdvX5xLC0iElthXtR51Q09RVafuINNfmbWbUI="},"public":{"type":"Buffer","data":"2lF0n68I9i3YMKP79XYT2eDJcVC7SU/YF4VwLszrQGU="}}
---

ðŸ“„ middleware\auth\pre-key-29.json
---
{"private":{"type":"Buffer","data":"KIUSNDTEZfToOv77d5o+YN6xxmjyPZEX3AE1ZvJT0lk="},"public":{"type":"Buffer","data":"1DmIMOeHRrQa2e6UrHXkxBZ8SxhU2jih9zvEduHSgyA="}}
---

ðŸ“„ middleware\auth\pre-key-3.json
---
{"private":{"type":"Buffer","data":"WMKLlPR9Mbo9fLPnWfPO5ZGbSyDdRHjh9fxmpJcPFGU="},"public":{"type":"Buffer","data":"AFnT6O3KANmpV0VbHjDG2g4lbOuKZ8g97KbYfs5K2xY="}}
---

ðŸ“„ middleware\auth\pre-key-30.json
---
{"private":{"type":"Buffer","data":"yL/WRkaIQDXH+o+0mH9Xgktyc1IGc+vNLSNiaKFRyW0="},"public":{"type":"Buffer","data":"mifAf0cn+2myDPVQry34RkTOIdJpNxyNTx6QxzLIV2E="}}
---

ðŸ“„ middleware\auth\pre-key-4.json
---
{"private":{"type":"Buffer","data":"iKDVpWd6nU6JNjEr0NSss8zcGlBQzCurPs28ac36Omo="},"public":{"type":"Buffer","data":"zH23p3pHG3vAoyZBgwSDGxw7NA4eD4D+gVN42J2fwyo="}}
---

ðŸ“„ middleware\auth\pre-key-5.json
---
{"private":{"type":"Buffer","data":"mCXf37COVKv9N/s3LOhZquiu2TkpwsGcBH5jasu4G3U="},"public":{"type":"Buffer","data":"EEtDWeQrN7vvC9THHCwwG0FZpWl34LgUZLfFiR1onQ8="}}
---

ðŸ“„ middleware\auth\pre-key-6.json
---
{"private":{"type":"Buffer","data":"ePgEP5hUBOWLkCLfW3T9qzq2QqssLSpzpPP96hoto1c="},"public":{"type":"Buffer","data":"v3GU3MPFOha9YH+Feav8EB7G+b6VQOA1nbIFoHqClys="}}
---

ðŸ“„ middleware\auth\pre-key-8.json
---
{"private":{"type":"Buffer","data":"GDg7nWG36Yr9P5JTV+9yUYyvcmbXD0mnV75E/2BPmnk="},"public":{"type":"Buffer","data":"/p/tWDUJkxH4aJtVdSyhuSevgf7OKL88WUXCONOPPCU="}}
---

ðŸ“„ middleware\auth\pre-key-9.json
---
{"private":{"type":"Buffer","data":"ANDMMmlbqhNg1sP75iZkf1VQNHWMSIdquJv3iXnQjU8="},"public":{"type":"Buffer","data":"ierX+ZmnT//I7G/Y2S23CheAfkKRB9KfFwFwkOo2OGo="}}
---

ðŸ“„ middleware\auth\session-51914743214.0.json
---
{"_sessions":{"BcJSJnLxOB4J2UCuwihzvECQrk2h5XdEtnNkV6it5nMf":{"registrationId":765876405,"currentRatchet":{"ephemeralKeyPair":{"pubKey":"BWyBZ273gaIOG2TCkU2QP660uA2diGYw/t/Jc3Y6+ssK","privKey":"qBAW7hmDVX6nhElK/KHsRTI9Kow8TyjTqmjmUs+u2UQ="},"lastRemoteEphemeralKey":"BZ+v8Q+RZOc5L8yxiJPOROfRfuG0vyGMQN2BZrp63n0N","previousCounter":0,"rootKey":"Z7RmZaUOwBoJjjt/4JGHuvtspwWYj3yxnRVRg2/p/Yc="},"indexInfo":{"baseKey":"BcJSJnLxOB4J2UCuwihzvECQrk2h5XdEtnNkV6it5nMf","baseKeyType":2,"closed":-1,"used":1740032123956,"created":1740032123956,"remoteIdentityKey":"BYpK2qp6UalV4nkjg2zymcL/Mj9Njs6FHViw2LBoEDdV"},"_chains":{"BZ+v8Q+RZOc5L8yxiJPOROfRfuG0vyGMQN2BZrp63n0N":{"chainKey":{"counter":0,"key":"T99MYSGARFjsVKr4aedEYuCAOnStSdNvH+46pyX7LVI="},"chainType":2,"messageKeys":{}},"BWyBZ273gaIOG2TCkU2QP660uA2diGYw/t/Jc3Y6+ssK":{"chainKey":{"counter":-1,"key":"Af4ZAfG4rCYOnbUGX4+WmytEvlOjh6qNpQrePV9P5CE="},"chainType":1,"messageKeys":{}}}}},"version":"v1"}
---

ðŸ“„ middleware\auth\session-51928241365.0.json
---
{"_sessions":{"BWTgqH6cI2FuRrnJ7gkjEpfkPcX/VqvKOkSNu93eRp5G":{"registrationId":721182061,"currentRatchet":{"ephemeralKeyPair":{"pubKey":"BRjnoD+1nF6g7oBNrcY3Lz1BEXGDoffr7tTYboJQcrpW","privKey":"uH+7vN5ObfqOagNWzAtAaLqy1OEybr1D0HKZCS0PdU0="},"lastRemoteEphemeralKey":"BdvneypfsF0w/BsGYp6UwUl9pG4Qo8atTsWFeAt8C/sJ","previousCounter":0,"rootKey":"raPPix0Cd09Ayivw7c/lAFyt8k9Uf/SOfdUowvuBApE="},"indexInfo":{"baseKey":"BWTgqH6cI2FuRrnJ7gkjEpfkPcX/VqvKOkSNu93eRp5G","baseKeyType":2,"closed":-1,"used":1740032101079,"created":1740032101079,"remoteIdentityKey":"BeuO+wX/zd8AN8OcdQhDsj+SAV9LxS3MOP+Q+tx1IbxO"},"_chains":{"BdvneypfsF0w/BsGYp6UwUl9pG4Qo8atTsWFeAt8C/sJ":{"chainKey":{"counter":7,"key":"NKpg91eR9bfxmBk2OqKEs5WgM3jNjPbt5i1YEIkyOCY="},"chainType":2,"messageKeys":{}},"BRjnoD+1nF6g7oBNrcY3Lz1BEXGDoffr7tTYboJQcrpW":{"chainKey":{"counter":-1,"key":"eQr8WWgDqz+0Gv5Qmz4zH5WsEZwn/GhiGz/8lmYAy8Q="},"chainType":1,"messageKeys":{}}}}},"version":"v1"}
---

ðŸ“„ middleware\combined.log
---
{"level":"info","message":"Starting WhatsApp Bot Middleware...","timestamp":"2025-02-20T06:11:59.394Z"}
{"level":"error","message":"Failed to start middleware: makeWASocket is not a function","stack":"TypeError: makeWASocket is not a function\n    at WhatsAppPlatform.connect (file:///D:/whatsapp_bot/middleware/dist/services/messaging/WhatsAppPlatform.js:14:27)\n    at async main (file:///D:/whatsapp_bot/middleware/dist/index.js:18:9)","timestamp":"2025-02-20T06:11:59.438Z"}
{"level":"info","message":"Starting WhatsApp Bot Middleware...","timestamp":"2025-02-20T06:13:09.868Z"}
{"level":"info","message":"Starting WhatsApp Bot Middleware...","timestamp":"2025-02-20T06:13:15.784Z"}
{"level":"info","message":"Starting WhatsApp Bot Middleware...","timestamp":"2025-02-20T06:13:30.425Z"}
{"level":"info","message":"Starting WhatsApp Bot Middleware...","timestamp":"2025-02-20T06:14:36.081Z"}
{"level":"info","message":"WhatsApp platform connected successfully","timestamp":"2025-02-20T06:14:36.178Z"}
{"level":"info","message":"WebSocket server started on port 8080","timestamp":"2025-02-20T06:14:36.181Z"}
{"level":"info","message":"WebSocket server initialized on port 8080","timestamp":"2025-02-20T06:14:36.182Z"}
{"level":"info","message":"WhatsApp Bot Middleware running on port 8080","timestamp":"2025-02-20T06:14:36.182Z"}

---

ðŸ“‚ middleware\dist/

ðŸ“„ middleware\dist\index.d.ts
---
export {};

---

ðŸ“„ middleware\dist\index.js
---
import { WhatsAppPlatform } from './services/messaging/WhatsAppPlatform.js';
import { WebSocketService } from './services/websocket/WebSocketServer.js';
import { Logger } from './services/logger/Logger.js';
import { config } from 'dotenv';
import { join } from 'path';
// Load environment variables
config();
// Configuration
const WS_PORT = parseInt(process.env.WS_PORT || '8080', 10);
const AUTH_PATH = join(process.cwd(), 'auth');
async function main() {
    try {
        // Initialize logger
        Logger.initialize();
        Logger.info('Starting WhatsApp Bot Middleware...');
        // Initialize WhatsApp platform
        const whatsapp = new WhatsAppPlatform(AUTH_PATH);
        await whatsapp.connect();
        Logger.info('WhatsApp platform connected successfully');
        // Initialize WebSocket server
        const wsServer = new WebSocketService(WS_PORT);
        Logger.info(`WebSocket server initialized on port ${WS_PORT}`);
        // Handle process termination
        const cleanup = async () => {
            Logger.info('Shutting down...');
            await whatsapp.disconnect();
            wsServer.close();
            process.exit(0);
        };
        process.on('SIGINT', cleanup);
        process.on('SIGTERM', cleanup);
        Logger.info(`WhatsApp Bot Middleware running on port ${WS_PORT}`);
    }
    catch (error) {
        Logger.error('Failed to start middleware:', error);
        process.exit(1);
    }
}
main();
//# sourceMappingURL=index.js.map
---

ðŸ“„ middleware\dist\index.js.map
---
{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,gBAAgB,EAAE,MAAM,0CAA0C,CAAC;AAC5E,OAAO,EAAE,gBAAgB,EAAE,MAAM,yCAAyC,CAAC;AAC3E,OAAO,EAAE,MAAM,EAAE,MAAM,6BAA6B,CAAC;AACrD,OAAO,EAAE,MAAM,EAAE,MAAM,QAAQ,CAAC;AAChC,OAAO,EAAE,IAAI,EAAE,MAAM,MAAM,CAAC;AAE5B,6BAA6B;AAC7B,MAAM,EAAE,CAAC;AAET,gBAAgB;AAChB,MAAM,OAAO,GAAG,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,OAAO,IAAI,MAAM,EAAE,EAAE,CAAC,CAAC;AAC5D,MAAM,SAAS,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,EAAE,EAAE,MAAM,CAAC,CAAC;AAE9C,KAAK,UAAU,IAAI;IACf,IAAI,CAAC;QACD,oBAAoB;QACpB,MAAM,CAAC,UAAU,EAAE,CAAC;QACpB,MAAM,CAAC,IAAI,CAAC,qCAAqC,CAAC,CAAC;QAEnD,+BAA+B;QAC/B,MAAM,QAAQ,GAAG,IAAI,gBAAgB,CAAC,SAAS,CAAC,CAAC;QACjD,MAAM,QAAQ,CAAC,OAAO,EAAE,CAAC;QACzB,MAAM,CAAC,IAAI,CAAC,0CAA0C,CAAC,CAAC;QAExD,8BAA8B;QAC9B,MAAM,QAAQ,GAAG,IAAI,gBAAgB,CAAC,OAAO,CAAC,CAAC;QAC/C,MAAM,CAAC,IAAI,CAAC,wCAAwC,OAAO,EAAE,CAAC,CAAC;QAE/D,6BAA6B;QAC7B,MAAM,OAAO,GAAG,KAAK,IAAI,EAAE;YACvB,MAAM,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC;YAChC,MAAM,QAAQ,CAAC,UAAU,EAAE,CAAC;YAC5B,QAAQ,CAAC,KAAK,EAAE,CAAC;YACjB,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QACpB,CAAC,CAAC;QAEF,OAAO,CAAC,EAAE,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;QAC9B,OAAO,CAAC,EAAE,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;QAE/B,MAAM,CAAC,IAAI,CAAC,2CAA2C,OAAO,EAAE,CAAC,CAAC;IACtE,CAAC;IAAC,OAAO,KAAK,EAAE,CAAC;QACb,MAAM,CAAC,KAAK,CAAC,6BAA6B,EAAE,KAAK,CAAC,CAAC;QACnD,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IACpB,CAAC;AACL,CAAC;AAED,IAAI,EAAE,CAAC"}
---

ðŸ“‚ middleware\dist\services/

ðŸ“‚ middleware\dist\services\logger/

ðŸ“„ middleware\dist\services\logger\Logger.d.ts
---
import winston from 'winston';
/**
 * Logger configuration and setup
 */
export declare class Logger {
    private static instance;
    /**
     * Initialize the logger with custom configuration
     */
    static initialize(): winston.Logger;
    /**
     * Get the logger instance
     */
    static getInstance(): winston.Logger;
    /**
     * Log an info message
     */
    static info(message: string, meta?: any): void;
    /**
     * Log an error message
     */
    static error(message: string, meta?: any): void;
    /**
     * Log a warning message
     */
    static warn(message: string, meta?: any): void;
    /**
     * Log a debug message
     */
    static debug(message: string, meta?: any): void;
}

---

ðŸ“„ middleware\dist\services\logger\Logger.js
---
import winston from 'winston';
/**
 * Logger configuration and setup
 */
export class Logger {
    /**
     * Initialize the logger with custom configuration
     */
    static initialize() {
        if (!Logger.instance) {
            Logger.instance = winston.createLogger({
                level: process.env.LOG_LEVEL || 'info',
                format: winston.format.combine(winston.format.timestamp(), winston.format.json()),
                transports: [
                    new winston.transports.Console({
                        format: winston.format.combine(winston.format.colorize(), winston.format.simple())
                    }),
                    new winston.transports.File({
                        filename: 'error.log',
                        level: 'error'
                    }),
                    new winston.transports.File({
                        filename: 'combined.log'
                    })
                ]
            });
        }
        return Logger.instance;
    }
    /**
     * Get the logger instance
     */
    static getInstance() {
        if (!Logger.instance) {
            Logger.initialize();
        }
        return Logger.instance;
    }
    /**
     * Log an info message
     */
    static info(message, meta) {
        Logger.getInstance().info(message, meta);
    }
    /**
     * Log an error message
     */
    static error(message, meta) {
        Logger.getInstance().error(message, meta);
    }
    /**
     * Log a warning message
     */
    static warn(message, meta) {
        Logger.getInstance().warn(message, meta);
    }
    /**
     * Log a debug message
     */
    static debug(message, meta) {
        Logger.getInstance().debug(message, meta);
    }
}
//# sourceMappingURL=Logger.js.map
---

ðŸ“„ middleware\dist\services\logger\Logger.js.map
---
{"version":3,"file":"Logger.js","sourceRoot":"","sources":["../../../src/services/logger/Logger.ts"],"names":[],"mappings":"AAAA,OAAO,OAAO,MAAM,SAAS,CAAC;AAE9B;;GAEG;AACH,MAAM,OAAO,MAAM;IAGf;;OAEG;IACI,MAAM,CAAC,UAAU;QACpB,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE,CAAC;YACnB,MAAM,CAAC,QAAQ,GAAG,OAAO,CAAC,YAAY,CAAC;gBACnC,KAAK,EAAE,OAAO,CAAC,GAAG,CAAC,SAAS,IAAI,MAAM;gBACtC,MAAM,EAAE,OAAO,CAAC,MAAM,CAAC,OAAO,CAC1B,OAAO,CAAC,MAAM,CAAC,SAAS,EAAE,EAC1B,OAAO,CAAC,MAAM,CAAC,IAAI,EAAE,CACxB;gBACD,UAAU,EAAE;oBACR,IAAI,OAAO,CAAC,UAAU,CAAC,OAAO,CAAC;wBAC3B,MAAM,EAAE,OAAO,CAAC,MAAM,CAAC,OAAO,CAC1B,OAAO,CAAC,MAAM,CAAC,QAAQ,EAAE,EACzB,OAAO,CAAC,MAAM,CAAC,MAAM,EAAE,CAC1B;qBACJ,CAAC;oBACF,IAAI,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC;wBACxB,QAAQ,EAAE,WAAW;wBACrB,KAAK,EAAE,OAAO;qBACjB,CAAC;oBACF,IAAI,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC;wBACxB,QAAQ,EAAE,cAAc;qBAC3B,CAAC;iBACL;aACJ,CAAC,CAAC;QACP,CAAC;QACD,OAAO,MAAM,CAAC,QAAQ,CAAC;IAC3B,CAAC;IAED;;OAEG;IACI,MAAM,CAAC,WAAW;QACrB,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE,CAAC;YACnB,MAAM,CAAC,UAAU,EAAE,CAAC;QACxB,CAAC;QACD,OAAO,MAAM,CAAC,QAAQ,CAAC;IAC3B,CAAC;IAED;;OAEG;IACI,MAAM,CAAC,IAAI,CAAC,OAAe,EAAE,IAAU;QAC1C,MAAM,CAAC,WAAW,EAAE,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;IAC7C,CAAC;IAED;;OAEG;IACI,MAAM,CAAC,KAAK,CAAC,OAAe,EAAE,IAAU;QAC3C,MAAM,CAAC,WAAW,EAAE,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;IAC9C,CAAC;IAED;;OAEG;IACI,MAAM,CAAC,IAAI,CAAC,OAAe,EAAE,IAAU;QAC1C,MAAM,CAAC,WAAW,EAAE,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;IAC7C,CAAC;IAED;;OAEG;IACI,MAAM,CAAC,KAAK,CAAC,OAAe,EAAE,IAAU;QAC3C,MAAM,CAAC,WAAW,EAAE,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;IAC9C,CAAC;CACJ"}
---

ðŸ“‚ middleware\dist\services\messaging/

ðŸ“„ middleware\dist\services\messaging\MessagingPlatform.d.ts
---
/**
 * Abstract interface for messaging platform integration
 */
export interface MessagingPlatform {
    connect(): Promise<void>;
    disconnect(): Promise<void>;
    sendMessage(to: string, content: string, options?: any): Promise<any>;
    onMessage(callback: (message: any) => void): void;
    onConnectionUpdate(callback: (update: any) => void): void;
    getStatus(): string;
}
/**
 * Event types for messaging platform
 */
export declare enum MessageEventType {
    RECEIVED = "message.received",
    SENT = "message.sent",
    DELIVERED = "message.delivered",
    READ = "message.read",
    CONNECTION_UPDATE = "connection.update"
}
/**
 * Base message structure
 */
export interface Message {
    id: string;
    from: string;
    to: string;
    content: string;
    timestamp: number;
    type: string;
    metadata?: any;
}
/**
 * Connection status types
 */
export declare enum ConnectionStatus {
    CONNECTING = "connecting",
    CONNECTED = "connected",
    DISCONNECTED = "disconnected",
    AUTHENTICATED = "authenticated",
    ERROR = "error"
}

---

ðŸ“„ middleware\dist\services\messaging\MessagingPlatform.js
---
/**
 * Event types for messaging platform
 */
export var MessageEventType;
(function (MessageEventType) {
    MessageEventType["RECEIVED"] = "message.received";
    MessageEventType["SENT"] = "message.sent";
    MessageEventType["DELIVERED"] = "message.delivered";
    MessageEventType["READ"] = "message.read";
    MessageEventType["CONNECTION_UPDATE"] = "connection.update";
})(MessageEventType || (MessageEventType = {}));
/**
 * Connection status types
 */
export var ConnectionStatus;
(function (ConnectionStatus) {
    ConnectionStatus["CONNECTING"] = "connecting";
    ConnectionStatus["CONNECTED"] = "connected";
    ConnectionStatus["DISCONNECTED"] = "disconnected";
    ConnectionStatus["AUTHENTICATED"] = "authenticated";
    ConnectionStatus["ERROR"] = "error";
})(ConnectionStatus || (ConnectionStatus = {}));
//# sourceMappingURL=MessagingPlatform.js.map
---

ðŸ“„ middleware\dist\services\messaging\MessagingPlatform.js.map
---
{"version":3,"file":"MessagingPlatform.js","sourceRoot":"","sources":["../../../src/services/messaging/MessagingPlatform.ts"],"names":[],"mappings":"AAYA;;GAEG;AACH,MAAM,CAAN,IAAY,gBAMX;AAND,WAAY,gBAAgB;IACxB,iDAA6B,CAAA;IAC7B,yCAAqB,CAAA;IACrB,mDAA+B,CAAA;IAC/B,yCAAqB,CAAA;IACrB,2DAAuC,CAAA;AAC3C,CAAC,EANW,gBAAgB,KAAhB,gBAAgB,QAM3B;AAeD;;GAEG;AACH,MAAM,CAAN,IAAY,gBAMX;AAND,WAAY,gBAAgB;IACxB,6CAAyB,CAAA;IACzB,2CAAuB,CAAA;IACvB,iDAA6B,CAAA;IAC7B,mDAA+B,CAAA;IAC/B,mCAAe,CAAA;AACnB,CAAC,EANW,gBAAgB,KAAhB,gBAAgB,QAM3B"}
---

ðŸ“„ middleware\dist\services\messaging\types.d.ts
---
export declare enum ConnectionStatus {
    DISCONNECTED = "DISCONNECTED",
    CONNECTING = "CONNECTING",
    AUTHENTICATED = "AUTHENTICATED",
    ERROR = "ERROR"
}
export declare enum MessageEventType {
    RECEIVED = "message.received",
    SENT = "message.sent",
    CONNECTION_UPDATE = "connection.update"
}
export interface Message {
    id: string;
    from: string;
    to: string;
    content: string;
    timestamp: number;
    type: string;
    metadata?: any;
}

---

ðŸ“„ middleware\dist\services\messaging\types.js
---
export var ConnectionStatus;
(function (ConnectionStatus) {
    ConnectionStatus["DISCONNECTED"] = "DISCONNECTED";
    ConnectionStatus["CONNECTING"] = "CONNECTING";
    ConnectionStatus["AUTHENTICATED"] = "AUTHENTICATED";
    ConnectionStatus["ERROR"] = "ERROR";
})(ConnectionStatus || (ConnectionStatus = {}));
export var MessageEventType;
(function (MessageEventType) {
    MessageEventType["RECEIVED"] = "message.received";
    MessageEventType["SENT"] = "message.sent";
    MessageEventType["CONNECTION_UPDATE"] = "connection.update";
})(MessageEventType || (MessageEventType = {}));
//# sourceMappingURL=types.js.map
---

ðŸ“„ middleware\dist\services\messaging\types.js.map
---
{"version":3,"file":"types.js","sourceRoot":"","sources":["../../../src/services/messaging/types.ts"],"names":[],"mappings":"AAAA,MAAM,CAAN,IAAY,gBAKX;AALD,WAAY,gBAAgB;IACxB,iDAA6B,CAAA;IAC7B,6CAAyB,CAAA;IACzB,mDAA+B,CAAA;IAC/B,mCAAe,CAAA;AACnB,CAAC,EALW,gBAAgB,KAAhB,gBAAgB,QAK3B;AAED,MAAM,CAAN,IAAY,gBAIX;AAJD,WAAY,gBAAgB;IACxB,iDAA6B,CAAA;IAC7B,yCAAqB,CAAA;IACrB,2DAAuC,CAAA;AAC3C,CAAC,EAJW,gBAAgB,KAAhB,gBAAgB,QAI3B"}
---

ðŸ“„ middleware\dist\services\messaging\WhatsAppPlatform.d.ts
---
import { EventEmitter } from 'events';
import { MessagingPlatform, Message } from './MessagingPlatform.js';
export declare class WhatsAppPlatform extends EventEmitter implements MessagingPlatform {
    private client;
    private status;
    private authPath;
    constructor(authPath?: string);
    connect(): Promise<void>;
    disconnect(): Promise<void>;
    sendMessage(to: string, content: string, options?: any): Promise<any>;
    onMessage(callback: (message: Message) => void): void;
    onConnectionUpdate(callback: (update: any) => void): void;
    getStatus(): string;
}

---

ðŸ“„ middleware\dist\services\messaging\WhatsAppPlatform.js
---
import { makeWASocket, DisconnectReason, useMultiFileAuthState } from '@whiskeysockets/baileys';
import { EventEmitter } from 'events';
import { ConnectionStatus, MessageEventType } from './MessagingPlatform.js';
export class WhatsAppPlatform extends EventEmitter {
    constructor(authPath = './auth') {
        super();
        this.status = ConnectionStatus.DISCONNECTED;
        this.authPath = authPath;
    }
    async connect() {
        try {
            this.status = ConnectionStatus.CONNECTING;
            const { state, saveCreds } = await useMultiFileAuthState(this.authPath);
            this.client = makeWASocket({
                auth: state,
                printQRInTerminal: true,
            });
            // Handle connection updates
            this.client.ev.on('connection.update', async (update) => {
                const { connection, lastDisconnect } = update;
                if (connection === 'close') {
                    const shouldReconnect = lastDisconnect?.error?.output?.statusCode !== DisconnectReason.loggedOut;
                    if (shouldReconnect) {
                        await this.connect();
                    }
                    else {
                        this.status = ConnectionStatus.DISCONNECTED;
                    }
                }
                else if (connection === 'open') {
                    this.status = ConnectionStatus.AUTHENTICATED;
                }
                this.emit(MessageEventType.CONNECTION_UPDATE, {
                    status: this.status,
                    update
                });
            });
            // Save credentials on update
            this.client.ev.on('creds.update', saveCreds);
            // Handle incoming messages
            this.client.ev.on('messages.upsert', (m) => {
                const msg = m.messages[0];
                if (!msg.key.fromMe) {
                    const message = {
                        id: msg.key.id,
                        from: msg.key.remoteJid,
                        to: msg.key.remoteJid,
                        content: msg.message?.conversation || msg.message?.extendedTextMessage?.text || '',
                        timestamp: msg.messageTimestamp,
                        type: 'text',
                        metadata: msg
                    };
                    this.emit(MessageEventType.RECEIVED, message);
                }
            });
        }
        catch (error) {
            this.status = ConnectionStatus.ERROR;
            throw error;
        }
    }
    async disconnect() {
        if (this.client) {
            this.client.end();
            this.status = ConnectionStatus.DISCONNECTED;
        }
    }
    async sendMessage(to, content, options = {}) {
        if (!this.client || this.status !== ConnectionStatus.AUTHENTICATED) {
            throw new Error('WhatsApp client is not connected');
        }
        try {
            const msg = await this.client.sendMessage(to, { text: content });
            const message = {
                id: msg.key.id,
                from: msg.key.remoteJid,
                to: to,
                content: content,
                timestamp: Date.now(),
                type: 'text',
                metadata: msg
            };
            this.emit(MessageEventType.SENT, message);
            return message;
        }
        catch (error) {
            throw error;
        }
    }
    onMessage(callback) {
        this.on(MessageEventType.RECEIVED, callback);
    }
    onConnectionUpdate(callback) {
        this.on(MessageEventType.CONNECTION_UPDATE, callback);
    }
    getStatus() {
        return this.status;
    }
}
//# sourceMappingURL=WhatsAppPlatform.js.map
---

ðŸ“„ middleware\dist\services\messaging\WhatsAppPlatform.js.map
---
{"version":3,"file":"WhatsAppPlatform.js","sourceRoot":"","sources":["../../../src/services/messaging/WhatsAppPlatform.ts"],"names":[],"mappings":"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"}
---

ðŸ“‚ middleware\dist\services\websocket/

ðŸ“„ middleware\dist\services\websocket\WebSocketServer.d.ts
---
export interface Message {
    id: string;
    from: string;
    to: string;
    content: string;
    timestamp: number;
    type: string;
    metadata: any;
}
export declare enum ConnectionStatus {
    CONNECTED = "CONNECTED",
    DISCONNECTED = "DISCONNECTED"
}
export declare enum MessageEventType {
    RECEIVED = "message_received",
    CONNECTION_UPDATE = "connection_update"
}
import { MessagingPlatform } from '../messaging/MessagingPlatform';
import { EventEmitter } from 'events';
export declare class WebSocketService extends EventEmitter implements MessagingPlatform {
    private wss;
    private clients;
    private status;
    private readonly MAX_RECONNECT_ATTEMPTS;
    private readonly RECONNECT_INTERVAL;
    private readonly MAX_QUEUE_SIZE;
    constructor(port: number);
    private handleConnection;
    private handleMessage;
    private handleDisconnection;
    private handleError;
    private attemptReconnection;
    private broadcast;
    private sendWithRetry;
    private queueMessage;
    connect(): Promise<void>;
    disconnect(): Promise<void>;
    sendMessage(to: string, content: string, options?: any): Promise<any>;
    onMessage(callback: (message: Message) => void): void;
    onConnectionUpdate(callback: (update: any) => void): void;
    getStatus(): string;
    close(): void;
}

---

ðŸ“„ middleware\dist\services\websocket\WebSocketServer.js
---
import { WebSocketServer as WSServer, WebSocket } from 'ws';
export var ConnectionStatus;
(function (ConnectionStatus) {
    ConnectionStatus["CONNECTED"] = "CONNECTED";
    ConnectionStatus["DISCONNECTED"] = "DISCONNECTED";
})(ConnectionStatus || (ConnectionStatus = {}));
export var MessageEventType;
(function (MessageEventType) {
    MessageEventType["RECEIVED"] = "message_received";
    MessageEventType["CONNECTION_UPDATE"] = "connection_update";
})(MessageEventType || (MessageEventType = {}));
import { Logger } from '../logger/Logger.js';
import { EventEmitter } from 'events';
export class WebSocketService extends EventEmitter {
    constructor(port) {
        super();
        this.MAX_RECONNECT_ATTEMPTS = 5;
        this.RECONNECT_INTERVAL = 5000;
        this.MAX_QUEUE_SIZE = 100;
        this.clients = new Map();
        this.status = ConnectionStatus.DISCONNECTED;
        this.wss = new WSServer({ port });
        this.wss.on('connection', this.handleConnection.bind(this));
        this.status = ConnectionStatus.CONNECTED;
        Logger.info(`WebSocket server started on port ${port}`);
    }
    handleConnection(ws) {
        const clientId = Math.random().toString(36).substring(7);
        ws.id = clientId;
        ws.messageQueue = [];
        ws.reconnectAttempts = 0;
        this.clients.set(clientId, ws);
        Logger.info(`New WebSocket client connected: ${clientId}`);
        ws.on('message', (data) => this.handleMessage(ws, data));
        ws.on('close', () => this.handleDisconnection(ws));
        ws.on('error', (error) => this.handleError(ws, error));
        // Send connection status
        this.emit(MessageEventType.CONNECTION_UPDATE, {
            status: this.status,
            clientId
        });
    }
    handleMessage(ws, data) {
        try {
            const message = JSON.parse(data.toString());
            Logger.info(`Received message from client ${ws.id}:`, message);
            const formattedMessage = {
                id: Math.random().toString(36).substring(7),
                from: ws.id || 'unknown',
                to: message.to || 'broadcast',
                content: message.content || '',
                timestamp: Date.now(),
                type: message.type || 'text',
                metadata: message
            };
            this.emit(MessageEventType.RECEIVED, formattedMessage);
        }
        catch (error) {
            Logger.error('Error parsing WebSocket message:', error);
        }
    }
    handleDisconnection(ws) {
        if (!ws.id)
            return;
        Logger.info(`Client disconnected: ${ws.id}`);
        if (ws.reconnectAttempts < this.MAX_RECONNECT_ATTEMPTS) {
            ws.reconnectAttempts++;
            setTimeout(() => this.attemptReconnection(ws), this.RECONNECT_INTERVAL);
        }
        else {
            this.clients.delete(ws.id);
            this.emit(MessageEventType.CONNECTION_UPDATE, {
                status: ConnectionStatus.DISCONNECTED,
                clientId: ws.id
            });
        }
    }
    handleError(ws, error) {
        Logger.error(`WebSocket error for client ${ws.id}:`, error);
    }
    attemptReconnection(ws) {
        if (!ws.id)
            return;
        try {
            if (ws.readyState === WebSocket.CLOSED) {
                Logger.info(`Attempting to reconnect client ${ws.id}`);
                // In a real implementation, you would need to handle the actual reconnection
                // This is just a placeholder for the reconnection logic
            }
        }
        catch (error) {
            Logger.error(`Reconnection failed for client ${ws.id}:`, error);
        }
    }
    broadcast(data) {
        const message = JSON.stringify(data);
        this.clients.forEach((client) => {
            if (client.readyState === WebSocket.OPEN) {
                this.sendWithRetry(client, message);
            }
            else {
                this.queueMessage(client, data);
            }
        });
    }
    async sendWithRetry(client, message, maxRetries = 3) {
        let attempts = 0;
        const trySend = async () => {
            try {
                if (client.readyState === WebSocket.OPEN) {
                    client.send(message);
                    Logger.info(`Message sent to client ${client.id}`);
                }
                else if (attempts < maxRetries) {
                    attempts++;
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    await trySend();
                }
                else {
                    throw new Error(`Failed to send message after ${maxRetries} attempts`);
                }
            }
            catch (error) {
                Logger.error(`Error sending message to client ${client.id}:`, error);
                throw error;
            }
        };
        await trySend();
    }
    queueMessage(client, data) {
        if (client.messageQueue.length >= this.MAX_QUEUE_SIZE) {
            Logger.warn(`Message queue full for client ${client.id}, dropping oldest message`);
            client.messageQueue.shift();
        }
        client.messageQueue.push({
            data,
            attempts: 0,
            timestamp: Date.now()
        });
    }
    // MessagingPlatform interface implementation
    async connect() {
        this.status = ConnectionStatus.CONNECTED;
        this.emit(MessageEventType.CONNECTION_UPDATE, { status: this.status });
    }
    async disconnect() {
        this.status = ConnectionStatus.DISCONNECTED;
        this.clients.forEach(client => client.close());
        this.clients.clear();
        this.emit(MessageEventType.CONNECTION_UPDATE, { status: this.status });
    }
    async sendMessage(to, content, options = {}) {
        const message = {
            id: Math.random().toString(36).substring(7),
            from: 'server',
            to,
            content,
            timestamp: Date.now(),
            type: 'text',
            metadata: options
        };
        this.broadcast({
            type: 'message',
            data: message
        });
        return message;
    }
    onMessage(callback) {
        this.on(MessageEventType.RECEIVED, callback);
    }
    onConnectionUpdate(callback) {
        this.on(MessageEventType.CONNECTION_UPDATE, callback);
    }
    getStatus() {
        return this.status;
    }
    close() {
        this.wss.close();
    }
}
//# sourceMappingURL=WebSocketServer.js.map
---

ðŸ“„ middleware\dist\services\websocket\WebSocketServer.js.map
---
{"version":3,"file":"WebSocketServer.js","sourceRoot":"","sources":["../../../src/services/websocket/WebSocketServer.ts"],"names":[],"mappings":"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"}
---

ðŸ“„ middleware\error.log
---
{"level":"error","message":"Failed to start middleware: makeWASocket is not a function","stack":"TypeError: makeWASocket is not a function\n    at WhatsAppPlatform.connect (file:///D:/whatsapp_bot/middleware/dist/services/messaging/WhatsAppPlatform.js:14:27)\n    at async main (file:///D:/whatsapp_bot/middleware/dist/index.js:18:9)","timestamp":"2025-02-20T06:11:59.438Z"}
{"level":"error","message":"Failed to start middleware: makeWASocket is not a function","stack":"TypeError: makeWASocket is not a function\n    at WhatsAppPlatform.connect (file:///D:/whatsapp_bot/middleware/dist/services/messaging/WhatsAppPlatform.js:14:27)\n    at async main (file:///D:/whatsapp_bot/middleware/dist/index.js:18:9)","timestamp":"2025-02-20T06:13:09.917Z"}
{"level":"error","message":"Failed to start middleware: makeWASocket is not a function","stack":"TypeError: makeWASocket is not a function\n    at WhatsAppPlatform.connect (file:///D:/whatsapp_bot/middleware/dist/services/messaging/WhatsAppPlatform.js:14:27)\n    at async main (file:///D:/whatsapp_bot/middleware/dist/index.js:18:9)","timestamp":"2025-02-20T06:13:15.852Z"}
{"level":"error","message":"Failed to start middleware: makeWASocket is not a function","stack":"TypeError: makeWASocket is not a function\n    at WhatsAppPlatform.connect (file:///D:/whatsapp_bot/middleware/dist/services/messaging/WhatsAppPlatform.js:14:27)\n    at async main (file:///D:/whatsapp_bot/middleware/dist/index.js:18:9)","timestamp":"2025-02-20T06:13:30.472Z"}

---

ðŸ“‚ middleware\src/

ðŸ“„ middleware\src\index.ts
---
import { WhatsAppPlatform } from './services/messaging/WhatsAppPlatform.js';
import { WebSocketService } from './services/websocket/WebSocketServer.js';
import { Logger } from './services/logger/Logger.js';
import { config } from 'dotenv';
import { join } from 'path';

// Load environment variables
config();

// Configuration
const WS_PORT = parseInt(process.env.WS_PORT || '8080', 10);
const AUTH_PATH = join(process.cwd(), 'auth');

async function main() {
    try {
        // Initialize logger
        Logger.initialize();
        Logger.info('Starting WhatsApp Bot Middleware...');

        // Initialize WhatsApp platform
        const whatsapp = new WhatsAppPlatform(AUTH_PATH);
        await whatsapp.connect();
        Logger.info('WhatsApp platform connected successfully');

        // Initialize WebSocket server
        const wsServer = new WebSocketService(WS_PORT);
        Logger.info(`WebSocket server initialized on port ${WS_PORT}`);

        // Handle process termination
        const cleanup = async () => {
            Logger.info('Shutting down...');
            await whatsapp.disconnect();
            wsServer.close();
            process.exit(0);
        };

        process.on('SIGINT', cleanup);
        process.on('SIGTERM', cleanup);

        Logger.info(`WhatsApp Bot Middleware running on port ${WS_PORT}`);
    } catch (error) {
        Logger.error('Failed to start middleware:', error);
        process.exit(1);
    }
}

main();
---

ðŸ“‚ middleware\src\services/

ðŸ“‚ middleware\src\services\logger/

ðŸ“„ middleware\src\services\logger\Logger.ts
---
import winston from 'winston';

/**
 * Logger configuration and setup
 */
export class Logger {
    private static instance: winston.Logger;

    /**
     * Initialize the logger with custom configuration
     */
    public static initialize() {
        if (!Logger.instance) {
            Logger.instance = winston.createLogger({
                level: process.env.LOG_LEVEL || 'info',
                format: winston.format.combine(
                    winston.format.timestamp(),
                    winston.format.json()
                ),
                transports: [
                    new winston.transports.Console({
                        format: winston.format.combine(
                            winston.format.colorize(),
                            winston.format.simple()
                        )
                    }),
                    new winston.transports.File({ 
                        filename: 'error.log', 
                        level: 'error' 
                    }),
                    new winston.transports.File({ 
                        filename: 'combined.log' 
                    })
                ]
            });
        }
        return Logger.instance;
    }

    /**
     * Get the logger instance
     */
    public static getInstance(): winston.Logger {
        if (!Logger.instance) {
            Logger.initialize();
        }
        return Logger.instance;
    }

    /**
     * Log an info message
     */
    public static info(message: string, meta?: any) {
        Logger.getInstance().info(message, meta);
    }

    /**
     * Log an error message
     */
    public static error(message: string, meta?: any) {
        Logger.getInstance().error(message, meta);
    }

    /**
     * Log a warning message
     */
    public static warn(message: string, meta?: any) {
        Logger.getInstance().warn(message, meta);
    }

    /**
     * Log a debug message
     */
    public static debug(message: string, meta?: any) {
        Logger.getInstance().debug(message, meta);
    }
}
---

ðŸ“‚ middleware\src\services\messaging/

ðŸ“„ middleware\src\services\messaging\MessagingPlatform.ts
---
/**
 * Abstract interface for messaging platform integration
 */
export interface MessagingPlatform {
    connect(): Promise<void>;
    disconnect(): Promise<void>;
    sendMessage(to: string, content: string, options?: any): Promise<any>;
    onMessage(callback: (message: any) => void): void;
    onConnectionUpdate(callback: (update: any) => void): void;
    getStatus(): string;
}

/**
 * Event types for messaging platform
 */
export enum MessageEventType {
    RECEIVED = 'message.received',
    SENT = 'message.sent',
    DELIVERED = 'message.delivered',
    READ = 'message.read',
    CONNECTION_UPDATE = 'connection.update'
}

/**
 * Base message structure
 */
export interface Message {
    id: string;
    from: string;
    to: string;
    content: string;
    timestamp: number;
    type: string;
    metadata?: any;
}

/**
 * Connection status types
 */
export enum ConnectionStatus {
    CONNECTING = 'connecting',
    CONNECTED = 'connected',
    DISCONNECTED = 'disconnected',
    AUTHENTICATED = 'authenticated',
    ERROR = 'error'
}
---

ðŸ“„ middleware\src\services\messaging\types.ts
---
export enum ConnectionStatus {
    DISCONNECTED = 'DISCONNECTED',
    CONNECTING = 'CONNECTING',
    AUTHENTICATED = 'AUTHENTICATED',
    ERROR = 'ERROR'
}

export enum MessageEventType {
    RECEIVED = 'message.received',
    SENT = 'message.sent',
    CONNECTION_UPDATE = 'connection.update'
}

export interface Message {
    id: string;
    from: string;
    to: string;
    content: string;
    timestamp: number;
    type: string;
    metadata?: any;
}
---

ðŸ“„ middleware\src\services\messaging\WhatsAppPlatform.ts
---
import { makeWASocket, DisconnectReason, useMultiFileAuthState } from '@whiskeysockets/baileys';
import type { WASocket } from '@whiskeysockets/baileys';
import { Boom } from '@hapi/boom';
import { EventEmitter } from 'events';
import { MessagingPlatform, Message, ConnectionStatus, MessageEventType } from './MessagingPlatform.js';

export class WhatsAppPlatform extends EventEmitter implements MessagingPlatform {
    private client: any;
    private status: ConnectionStatus = ConnectionStatus.DISCONNECTED;
    private authPath: string;

    constructor(authPath: string = './auth') {
        super();
        this.authPath = authPath;
    }

    async connect(): Promise<void> {
        try {
            this.status = ConnectionStatus.CONNECTING;
            const { state, saveCreds } = await useMultiFileAuthState(this.authPath);

            this.client = makeWASocket({
                auth: state,
                printQRInTerminal: true,
            });

            // Handle connection updates
            this.client.ev.on('connection.update', async (update: any) => {
                const { connection, lastDisconnect } = update;

                if (connection === 'close') {
                    const shouldReconnect = (lastDisconnect?.error as Boom)?.output?.statusCode !== DisconnectReason.loggedOut;
                    if (shouldReconnect) {
                        await this.connect();
                    } else {
                        this.status = ConnectionStatus.DISCONNECTED;
                    }
                } else if (connection === 'open') {
                    this.status = ConnectionStatus.AUTHENTICATED;
                }

                this.emit(MessageEventType.CONNECTION_UPDATE, {
                    status: this.status,
                    update
                });
            });

            // Save credentials on update
            this.client.ev.on('creds.update', saveCreds);

            // Handle incoming messages
            this.client.ev.on('messages.upsert', (m: any) => {
                const msg = m.messages[0];
                if (!msg.key.fromMe) {
                    const message: Message = {
                        id: msg.key.id,
                        from: msg.key.remoteJid,
                        to: msg.key.remoteJid,
                        content: msg.message?.conversation || msg.message?.extendedTextMessage?.text || '',
                        timestamp: msg.messageTimestamp,
                        type: 'text',
                        metadata: msg
                    };
                    this.emit(MessageEventType.RECEIVED, message);
                }
            });

        } catch (error) {
            this.status = ConnectionStatus.ERROR;
            throw error;
        }
    }

    async disconnect(): Promise<void> {
        if (this.client) {
            this.client.end();
            this.status = ConnectionStatus.DISCONNECTED;
        }
    }

    async sendMessage(to: string, content: string, options: any = {}): Promise<any> {
        if (!this.client || this.status !== ConnectionStatus.AUTHENTICATED) {
            throw new Error('WhatsApp client is not connected');
        }

        try {
            const msg = await this.client.sendMessage(to, { text: content });
            const message: Message = {
                id: msg.key.id,
                from: msg.key.remoteJid,
                to: to,
                content: content,
                timestamp: Date.now(),
                type: 'text',
                metadata: msg
            };
            this.emit(MessageEventType.SENT, message);
            return message;
        } catch (error) {
            throw error;
        }
    }

    onMessage(callback: (message: Message) => void): void {
        this.on(MessageEventType.RECEIVED, callback);
    }

    onConnectionUpdate(callback: (update: any) => void): void {
        this.on(MessageEventType.CONNECTION_UPDATE, callback);
    }

    getStatus(): string {
        return this.status;
    }
}
---

ðŸ“‚ middleware\src\services\websocket/

ðŸ“„ middleware\src\services\websocket\WebSocketServer.ts
---
import { WebSocketServer as WSServer, WebSocket } from 'ws';
// Define types locally since module cannot be found
export interface Message {
    id: string;
    from: string;
    to: string;
    content: string;
    timestamp: number;
    type: string;
    metadata: any;
}

export enum ConnectionStatus {
    CONNECTED = 'CONNECTED',
    DISCONNECTED = 'DISCONNECTED'
}

export enum MessageEventType {
    RECEIVED = 'message_received',
    CONNECTION_UPDATE = 'connection_update'
}
import { MessagingPlatform } from '../messaging/MessagingPlatform';
import { Logger } from '../logger/Logger.js';
import { EventEmitter } from 'events';

interface QueuedMessage {
    data: any;
    attempts: number;
    timestamp: number;
}

interface WebSocketClient extends WebSocket {
    id?: string;
    messageQueue: QueuedMessage[];
    reconnectAttempts: number;
}

export class WebSocketService extends EventEmitter implements MessagingPlatform {
    private wss: WSServer;
    private clients: Map<string, WebSocketClient>;
    private status: ConnectionStatus;
    private readonly MAX_RECONNECT_ATTEMPTS = 5;
    private readonly RECONNECT_INTERVAL = 5000;
    private readonly MAX_QUEUE_SIZE = 100;

    constructor(port: number) {
        super();
        this.clients = new Map();
        this.status = ConnectionStatus.DISCONNECTED;
        this.wss = new WSServer({ port });
        
        this.wss.on('connection', this.handleConnection.bind(this));
        this.status = ConnectionStatus.CONNECTED;
        Logger.info(`WebSocket server started on port ${port}`);
    }

    private handleConnection(ws: WebSocketClient): void {
        const clientId = Math.random().toString(36).substring(7);
        ws.id = clientId;
        ws.messageQueue = [];
        ws.reconnectAttempts = 0;

        this.clients.set(clientId, ws);
        Logger.info(`New WebSocket client connected: ${clientId}`);

        ws.on('message', (data: string | Buffer | ArrayBuffer | Buffer[]) => this.handleMessage(ws, data));
        ws.on('close', () => this.handleDisconnection(ws));
        ws.on('error', (error: Error) => this.handleError(ws, error));

        // Send connection status
        this.emit(MessageEventType.CONNECTION_UPDATE, {
            status: this.status,
            clientId
        });
    }

    private handleMessage(ws: WebSocketClient, data: string | Buffer | ArrayBuffer | Buffer[]): void {
        try {
            const message = JSON.parse(data.toString());
            Logger.info(`Received message from client ${ws.id}:`, message);

            const formattedMessage: Message = {
                id: Math.random().toString(36).substring(7),
                from: ws.id || 'unknown',
                to: message.to || 'broadcast',
                content: message.content || '',
                timestamp: Date.now(),
                type: message.type || 'text',
                metadata: message
            };

            this.emit(MessageEventType.RECEIVED, formattedMessage);
        } catch (error) {
            Logger.error('Error parsing WebSocket message:', error);
        }
    }

    private handleDisconnection(ws: WebSocketClient): void {
        if (!ws.id) return;

        Logger.info(`Client disconnected: ${ws.id}`);
        
        if (ws.reconnectAttempts < this.MAX_RECONNECT_ATTEMPTS) {
            ws.reconnectAttempts++;
            setTimeout(() => this.attemptReconnection(ws), this.RECONNECT_INTERVAL);
        } else {
            this.clients.delete(ws.id);
            this.emit(MessageEventType.CONNECTION_UPDATE, {
                status: ConnectionStatus.DISCONNECTED,
                clientId: ws.id
            });
        }
    }

    private handleError(ws: WebSocketClient, error: Error): void {
        Logger.error(`WebSocket error for client ${ws.id}:`, error);
    }

    private attemptReconnection(ws: WebSocketClient): void {
        if (!ws.id) return;

        try {
            if (ws.readyState === WebSocket.CLOSED) {
                Logger.info(`Attempting to reconnect client ${ws.id}`);
                // In a real implementation, you would need to handle the actual reconnection
                // This is just a placeholder for the reconnection logic
            }
        } catch (error) {
            Logger.error(`Reconnection failed for client ${ws.id}:`, error);
        }
    }

    private broadcast(data: any): void {
        const message = JSON.stringify(data);
        this.clients.forEach((client) => {
            if (client.readyState === WebSocket.OPEN) {
                this.sendWithRetry(client, message);
            } else {
                this.queueMessage(client, data);
            }
        });
    }

    private async sendWithRetry(client: WebSocketClient, message: string, maxRetries: number = 3): Promise<void> {
        let attempts = 0;
        
        const trySend = async (): Promise<void> => {
            try {
                if (client.readyState === WebSocket.OPEN) {
                    client.send(message);
                    Logger.info(`Message sent to client ${client.id}`);
                } else if (attempts < maxRetries) {
                    attempts++;
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    await trySend();
                } else {
                    throw new Error(`Failed to send message after ${maxRetries} attempts`);
                }
            } catch (error) {
                Logger.error(`Error sending message to client ${client.id}:`, error);
                throw error;
            }
        };

        await trySend();
    }

    private queueMessage(client: WebSocketClient, data: any): void {
        if (client.messageQueue.length >= this.MAX_QUEUE_SIZE) {
            Logger.warn(`Message queue full for client ${client.id}, dropping oldest message`);
            client.messageQueue.shift();
        }

        client.messageQueue.push({
            data,
            attempts: 0,
            timestamp: Date.now()
        });
    }

    // MessagingPlatform interface implementation
    async connect(): Promise<void> {
        this.status = ConnectionStatus.CONNECTED;
        this.emit(MessageEventType.CONNECTION_UPDATE, { status: this.status });
    }

    async disconnect(): Promise<void> {
        this.status = ConnectionStatus.DISCONNECTED;
        this.clients.forEach(client => client.close());
        this.clients.clear();
        this.emit(MessageEventType.CONNECTION_UPDATE, { status: this.status });
    }

    async sendMessage(to: string, content: string, options: any = {}): Promise<any> {
        const message: Message = {
            id: Math.random().toString(36).substring(7),
            from: 'server',
            to,
            content,
            timestamp: Date.now(),
            type: 'text',
            metadata: options
        };

        this.broadcast({
            type: 'message',
            data: message
        });

        return message;
    }

    onMessage(callback: (message: Message) => void): void {
        this.on(MessageEventType.RECEIVED, callback);
    }

    onConnectionUpdate(callback: (update: any) => void): void {
        this.on(MessageEventType.CONNECTION_UPDATE, callback);
    }

    getStatus(): string {
        return this.status;
    }

    public close(): void {
        this.wss.close();
    }
}
---

ðŸ“‚ middleware\src\__tests__/

ðŸ“„ middleware\src\__tests__\websocket.test.ts
---
import { WebSocket } from 'ws';
import { describe, expect, test, beforeEach, afterEach, jest } from '@jest/globals';

describe('WebSocket Connection', () => {
    let ws: WebSocket;
    const TEST_SERVER_URL = 'ws://localhost:8000';

    beforeEach(() => {
        ws = new WebSocket(TEST_SERVER_URL);
    });

    afterEach(() => {
        ws.close();
    });

    test('should establish connection successfully', (done) => {
        ws.on('open', () => {
            expect(ws.readyState).toBe(WebSocket.OPEN);
            done();
        });
    });

    test('should handle message receiving', (done) => {
        const mockMessage = { type: 'test', content: 'Hello' };

        ws.on('message', (data) => {
            const message = JSON.parse(data.toString());
            expect(message).toEqual(mockMessage);
            done();
        });

        // Simulate receiving a message
        ws.emit('message', Buffer.from(JSON.stringify(mockMessage)));
    });

    test('should handle connection closure', (done) => {
        ws.on('close', () => {
            expect(ws.readyState).toBe(WebSocket.CLOSED);
            done();
        });

        ws.close();
    });

    test('should handle connection errors', (done) => {
        ws.on('error', (error) => {
            expect(error).toBeDefined();
            done();
        });

        // Simulate an error
        ws.emit('error', new Error('Test error'));
    });
});
---

ðŸ“„ PLAN.MD
---
Thought for
37s
Expand for details
AquÃ­ tienes un Plan Maestro completo y optimizado para guiar a Claude 3.5 Sonnet en la construcciÃ³n de un boilerplate ultraligero y modular para bots de mensajerÃ­a. Este plan asegura que Claude mantenga el contexto en cada paso, generando un sistema escalable, flexible y estable, adaptable a cualquier industria. A continuaciÃ³n, te detallo los pasos con sus respectivos prompts y explicaciones, diseÃ±ados para ser claros, especÃ­ficos y referenciales, permitiendo una construcciÃ³n coherente del boilerplate.

ðŸ”¥ Plan Maestro para Construir el Boilerplate Ultraligero y Modular con Claude 3.5 Sonnet ðŸš€
Objetivo: Que Claude construya un boilerplate ultraligero y modular para bots de mensajerÃ­a que se adapte a cualquier industria, con mÃ¡xima estabilidad, escalabilidad y flexibilidad.

Enfoque: Cada prompt estÃ¡ estructurado para proporcionar contexto claro, refiriÃ©ndose a pasos anteriores cuando sea necesario, y guiando a Claude hacia respuestas precisas y Ãºtiles. El plan se divide en siete pasos clave, cada uno con un propÃ³sito especÃ­fico.

ðŸŸ¢ Paso 1: Definir la arquitectura
Prompt para Claude:

â€œVoy a construir un boilerplate ultraligero y modular para bots de mensajerÃ­a. Quiero que sea escalable, fÃ¡cil de mantener y adaptable a cualquier industria, con integraciÃ³n para WhatsApp y otras plataformas, evitando dependencias innecesarias. DiseÃ±a una arquitectura basada en microservicios con:

Backend en Python con FastAPI para procesamiento avanzado de mensajes y almacenamiento (justifica por quÃ© FastAPI es mejor que Flask).
Middleware en Node.js con Baileys como puente temporal para WhatsApp, pero con una abstracciÃ³n para reemplazarlo fÃ¡cilmente por otras plataformas.
Frontend ultraligero en React (opcional, para interfaz de administraciÃ³n).
Base de datos en SQLite o PostgreSQL con Drizzle ORM.
MensajerÃ­a en tiempo real con WebSockets y un fallback a Webhooks.
PreparaciÃ³n opcional para colas (como Redis o RabbitMQ) para procesamiento asÃ­ncrono.
DiseÃ±a el esquema de la arquitectura (puedes usar un diagrama en texto o descripciÃ³n) y explÃ­came por quÃ© esta es la mejor opciÃ³n para estabilidad, escalabilidad y flexibilidad. Este serÃ¡ el Paso 1 de nuestro plan para construir el boilerplate completo.â€
ðŸ’¡ PropÃ³sito: Establecer una base arquitectÃ³nica sÃ³lida y justificable, proporcionando a Claude el marco inicial para todo el proyecto.

ðŸŸ¢ Paso 2: Generar la estructura de archivos
Prompt para Claude:

â€œBasÃ¡ndote en la arquitectura definida en el Paso 1, genera la estructura de archivos para el proyecto. Debe ser limpia, escalable y lÃ³gica, incluyendo:

backend/ (Python con FastAPI).
middleware/ (Node.js con Baileys y adaptadores).
frontend/ (React, opcional).
database/ (migraciones y modelos con Drizzle ORM).
config/ (archivos de configuraciÃ³n).
logs/ (manejador de logs).
tests/ (pruebas unitarias).
docs/ (documentaciÃ³n bÃ¡sica).
scripts/ (automatizaciones como despliegues).
Proporciona un Ã¡rbol de archivos detallado y explica el propÃ³sito de cada carpeta y archivo clave. Indica cÃ³mo esta estructura escalarÃ­a en proyectos grandes. Recuerda que estamos construyendo un boilerplate ultraligero y modular para bots de mensajerÃ­a.â€
ðŸ’¡ PropÃ³sito: Crear una base organizada y preparada para crecer, manteniendo el contexto arquitectÃ³nico del Paso 1.

ðŸŸ¢ Paso 3: Escribir el Backend en Python
Prompt para Claude:

â€œCon la estructura de archivos definida en el Paso 2, construye el backend en Python usando FastAPI. El backend debe:

Exponer una API REST con endpoints para recibir y enviar mensajes.
Usar WebSockets para comunicaciÃ³n en tiempo real.
Almacenar datos en SQLite o PostgreSQL con Drizzle ORM.
Implementar autenticaciÃ³n con API Keys (JWT opcional).
Incluir un logger configurable (por ejemplo, con logging de Python).
Dejar un esqueleto para integrar colas como Redis o RabbitMQ en el futuro (sin implementarlo).
Escribe el cÃ³digo base con una estructura modular, explicando cada componente. Recuerda que este backend es parte de un boilerplate ultraligero y modular para bots de mensajerÃ­a, como definimos en el Paso 1.â€
ðŸ’¡ PropÃ³sito: Generar un backend rÃ¡pido, modular y preparado para tiempo real, conectado con los pasos previos.

ðŸŸ¢ Paso 4: Construir el Middleware en Node.js
Prompt para Claude:

â€œCon el backend construido en el Paso 3, crea el middleware en Node.js con las siguientes caracterÃ­sticas:

Usa Baileys para conectarse a WhatsApp como implementaciÃ³n inicial.
Implementa un sistema de adaptadores (por ejemplo, una interfaz MessagingPlatform) para abstraer la plataforma y permitir cambiar WhatsApp por Telegram u otras fÃ¡cilmente.
Emite eventos a travÃ©s de WebSockets hacia el backend cuando lleguen mensajes.
Incluye un logger bÃ¡sico.
Escribe el cÃ³digo base, asegurÃ¡ndote de que la abstracciÃ³n sea clara y documentada. Este middleware debe ser flexible y desacoplado, como parte del boilerplate ultraligero y modular que estamos construyendo.â€
ðŸ’¡ PropÃ³sito: Hacer el middleware flexible y adaptable, integrÃ¡ndolo con el backend del Paso 3.

ðŸŸ¢ Paso 5: Crear la Base de Datos con Drizzle ORM
Prompt para Claude:

â€œBasÃ¡ndote en la estructura de archivos (Paso 2) y el backend (Paso 3), define la base de datos con Drizzle ORM para SQLite o PostgreSQL. Crea modelos para:

Usuarios (id, nombre, telÃ©fono, api_key).
Mensajes (id, usuario_id, contenido, estado, timestamp).
Sesiones (id, usuario_id, connection_status, timestamp).
Conversaciones (id, usuario_id, estado, Ãºltima_actividad).
Escribe las migraciones y la configuraciÃ³n de Drizzle ORM, optimizando para alto volumen de mensajes. Explica cÃ³mo estas tablas soportan un sistema de mensajerÃ­a escalable, alineado con el boilerplate ultraligero y modular que estamos desarrollando.â€
ðŸ’¡ PropÃ³sito: Establecer una base de datos eficiente y escalable, conectada con el backend.

ðŸŸ¢ Paso 6: Implementar WebSockets o Webhooks
Prompt para Claude:

â€œCon el backend (Paso 3) y el middleware (Paso 4) en su lugar, implementa un sistema de eventos en tiempo real:

Usa WebSockets en el backend (FastAPI) para emitir eventos cuando lleguen mensajes nuevos.
AÃ±ade un fallback a Webhooks para plataformas que no soporten WebSockets o como redundancia.
AsegÃºrate de que el middleware (Node.js) envÃ­e eventos al backend vÃ­a WebSockets.
Si hay frontend, incluye un ejemplo de cÃ³mo consumirÃ­a estos eventos en React.
Escribe el cÃ³digo para ambos componentes y explica cÃ³mo garantiza robustez en tiempo real. Este es un componente clave para la comunicaciÃ³n fluida en nuestro boilerplate ultraligero y modular.â€
ðŸ’¡ PropÃ³sito: Asegurar una comunicaciÃ³n fluida y confiable, uniendo backend y middleware.

ðŸŸ¢ Paso 7: Testear y Optimizar
Prompt para Claude:

â€œGenera pruebas unitarias y de integraciÃ³n para cada mÃ³dulo del boilerplate:

Usa Pytest para el backend, probando endpoints, WebSockets y manejo de mensajes.
Usa Jest para el middleware, verificando la conexiÃ³n a WhatsApp y emisiÃ³n de eventos.
Incluye una prueba simulada de alta concurrencia (por ejemplo, 100 mensajes simultÃ¡neos).
Opcionalmente, sugiere cÃ³mo usar Locust para pruebas de carga.
Escribe el cÃ³digo de las pruebas y explica cÃ³mo aseguran la estabilidad del sistema. Este paso es crucial para garantizar que nuestro boilerplate ultraligero y modular sea resistente y de alta calidad.â€
ðŸ’¡ PropÃ³sito: Garantizar la calidad y resistencia del boilerplate, validando todos los componentes previos.

ðŸ”¥ ConclusiÃ³n
Este Plan Maestro estÃ¡ diseÃ±ado para que Claude 3.5 Sonnet construya un boilerplate ultraligero, modular y escalable paso a paso. Los prompts son detallados, especÃ­ficos y mantienen el contexto al hacer referencia explÃ­cita a los pasos anteriores y al objetivo general. El resultado serÃ¡ un sistema con:

Backend sÃ³lido en FastAPI.
Middleware flexible con adaptadores.
Base de datos optimizada con Drizzle ORM.
ComunicaciÃ³n en tiempo real robusta mediante WebSockets y Webhooks.
Pruebas completas para estabilidad y calidad.
âš¡ Â¿Listo para empezar? Puedes ejecutar estos prompts uno por uno con Claude 3.5 Sonnet. Si prefieres, puedo simular las respuestas como Grok o ajustar algo mÃ¡s en el plan. Â¡Estoy aquÃ­ para ayudarte a llevarlo a la acciÃ³n! ðŸš€
---

ðŸ“„ PROJECT_STRUCTURE.md
---
# Detailed Project Structure

```
â”œâ”€â”€ backend/                    # Python FastAPI backend service
â”‚   â”œâ”€â”€ src/                   # Source code
â”‚   â”‚   â”œâ”€â”€ api/              # API endpoints
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ auth.py       # Authentication endpoints
â”‚   â”‚   â”‚   â”œâ”€â”€ messages.py   # Message handling endpoints
â”‚   â”‚   â”‚   â””â”€â”€ webhooks.py   # Webhook endpoints
â”‚   â”‚   â”œâ”€â”€ core/             # Core application code
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ config.py     # Configuration management
â”‚   â”‚   â”‚   â”œâ”€â”€ security.py   # Security utilities
â”‚   â”‚   â”‚   â””â”€â”€ logging.py    # Logging configuration
â”‚   â”‚   â”œâ”€â”€ models/           # Database models
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ message.py    # Message model
â”‚   â”‚   â”‚   â””â”€â”€ user.py       # User model
â”‚   â”‚   â”œâ”€â”€ services/         # Business logic
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ message.py    # Message processing
â”‚   â”‚   â”‚   â””â”€â”€ user.py       # User management
â”‚   â”‚   â””â”€â”€ main.py           # Application entry point
â”‚   â”œâ”€â”€ tests/                # Unit and integration tests
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ test_api/        # API tests
â”‚   â”‚   â”œâ”€â”€ test_services/   # Service tests
â”‚   â”‚   â””â”€â”€ conftest.py      # Test configuration
â”‚   â”œâ”€â”€ requirements.txt      # Python dependencies
â”‚   â””â”€â”€ README.md            # Backend documentation
â”‚
â”œâ”€â”€ middleware/               # Node.js WhatsApp integration service
â”‚   â”œâ”€â”€ src/                 # Source code
â”‚   â”‚   â”œâ”€â”€ config/         # Configuration files
â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts    # Config exports
â”‚   â”‚   â”‚   â””â”€â”€ whatsapp.ts # WhatsApp specific config
â”‚   â”‚   â”œâ”€â”€ services/       # Service implementations
â”‚   â”‚   â”‚   â”œâ”€â”€ whatsapp.ts # WhatsApp service
â”‚   â”‚   â”‚   â””â”€â”€ websocket.ts # WebSocket server
â”‚   â”‚   â”œâ”€â”€ types/          # TypeScript type definitions
â”‚   â”‚   â”œâ”€â”€ utils/          # Utility functions
â”‚   â”‚   â””â”€â”€ index.ts        # Entry point
â”‚   â”œâ”€â”€ tests/              # Test files
â”‚   â”œâ”€â”€ package.json        # Node.js dependencies
â”‚   â””â”€â”€ README.md          # Middleware documentation
â”‚
â”œâ”€â”€ frontend/               # React admin interface
â”‚   â”œâ”€â”€ src/               # Source code
â”‚   â”‚   â”œâ”€â”€ components/    # Reusable components
â”‚   â”‚   â”œâ”€â”€ pages/        # Page components
â”‚   â”‚   â”œâ”€â”€ services/     # API services
â”‚   â”‚   â”œâ”€â”€ store/        # State management
â”‚   â”‚   â”œâ”€â”€ styles/       # CSS/SCSS files
â”‚   â”‚   â””â”€â”€ App.tsx       # Root component
â”‚   â”œâ”€â”€ public/           # Static files
â”‚   â”œâ”€â”€ package.json      # Node.js dependencies
â”‚   â””â”€â”€ README.md        # Frontend documentation
â”‚
â”œâ”€â”€ database/             # Database management
â”‚   â”œâ”€â”€ migrations/      # Database migrations
â”‚   â”œâ”€â”€ schema.ts        # Drizzle schema definitions
â”‚   â””â”€â”€ config.ts        # Database configuration
â”‚
â”œâ”€â”€ config/              # Global configuration
â”‚   â”œâ”€â”€ development.env  # Development environment
â”‚   â”œâ”€â”€ production.env   # Production environment
â”‚   â””â”€â”€ test.env        # Test environment
â”‚
â”œâ”€â”€ logs/               # Application logs
â”‚   â”œâ”€â”€ error.log      # Error logs
â”‚   â””â”€â”€ access.log     # Access logs
â”‚
â”œâ”€â”€ docker/            # Docker configuration
â”‚   â”œâ”€â”€ backend/       # Backend Dockerfile
â”‚   â”œâ”€â”€ middleware/    # Middleware Dockerfile
â”‚   â””â”€â”€ frontend/      # Frontend Dockerfile
â”‚
â”œâ”€â”€ .gitignore        # Git ignore rules
â”œâ”€â”€ docker-compose.yml # Service orchestration
â””â”€â”€ README.md         # Project documentation
```

## Directory Descriptions

### Backend (/backend)
Contains the Python FastAPI backend service responsible for core business logic, API endpoints, and data management.

- **/src/api**: REST API endpoints and route handlers
- **/src/core**: Core application functionality and configurations
- **/src/models**: Database models and schemas
- **/src/services**: Business logic implementation

### Middleware (/middleware)
Houses the Node.js service that integrates with WhatsApp using Baileys and handles message routing.

- **/src/config**: Configuration management
- **/src/services**: WhatsApp and WebSocket implementations
- **/src/types**: TypeScript type definitions

### Frontend (/frontend)
Contains the React-based admin interface for bot management and monitoring.

- **/src/components**: Reusable UI components
- **/src/pages**: Page-level components
- **/src/services**: API integration services
- **/src/store**: State management (Redux/Context)

### Database (/database)
Manages database schema, migrations, and configuration using Drizzle ORM.

- **/migrations**: Database migration files
- **schema.ts**: Drizzle ORM schema definitions

### Config (/config)
Stores environment-specific configuration files.

### Logs (/logs)
Centralized logging directory for application logs.

### Docker (/docker)
Contains Dockerfile configurations for each service.

## Key Files

- **docker-compose.yml**: Defines and orchestrates all services
- **.gitignore**: Specifies which files Git should ignore
- **README.md**: Project documentation and setup instructions
---

ðŸ“„ README.md
---
# Lightweight Messaging Bot Boilerplate

A modular and scalable messaging bot platform that supports multiple messaging services, with initial support for WhatsApp.

## Architecture

The project follows a microservices architecture with the following components:

### Backend (Python)
- Message processing and business logic
- Data storage and retrieval
- API endpoints for service integration

### Middleware (Node.js)
- WhatsApp integration using Baileys
- Message routing and transformation
- WebSocket server for real-time communication

### Frontend (React)
- Admin interface for bot management
- Real-time message monitoring
- Configuration and analytics dashboard

### Database
- PostgreSQL with Drizzle ORM
- Efficient data persistence
- Scalable schema design

## Project Structure

```
â”œâ”€â”€ backend/           # Python backend service
â”‚   â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ tests/
â”‚   â””â”€â”€ requirements.txt
â”œâ”€â”€ middleware/        # Node.js middleware service
â”‚   â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ tests/
â”‚   â””â”€â”€ package.json
â”œâ”€â”€ frontend/         # React admin interface
â”‚   â”œâ”€â”€ src/
â”‚   â””â”€â”€ package.json
â”œâ”€â”€ docker/           # Docker configuration
â””â”€â”€ docker-compose.yml # Service orchestration
```

## Features

- ðŸš€ Modular architecture for easy scaling
- ðŸ”Œ Pluggable messaging platform integrations
- ðŸ’¬ Real-time message processing
- ðŸ“Š Admin dashboard for monitoring and configuration
- ðŸ”’ Secure message handling
- ðŸ“¦ Easy deployment with Docker

## Getting Started

1. Clone the repository
2. Install dependencies for each service
3. Configure environment variables
4. Start services using Docker Compose

## Development

Each service can be developed and tested independently:

### Backend
```bash
cd backend
pip install -r requirements.txt
python -m src.main
```

### Middleware
```bash
cd middleware
npm install
npm run dev
```

### Frontend
```bash
cd frontend
npm install
npm run dev
```

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## License

MIT
---